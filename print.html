<!DOCTYPE HTML>
<html lang="en" class="adastra-theme" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Ad Astra Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!------------------------------------------------------------------------------
          This file is part of "Ad Astra", an embeddable scripting programming
          language platform.
        
          This work is proprietary software with source-available code.
        
          To copy, use, distribute, or contribute to this work, you must agree to
          the terms of the General License Agreement:
        
          https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md
        
          The agreement grants a Basic Commercial License, allowing you to use
          this work in non-commercial and limited commercial products with a total
          gross revenue cap. To remove this commercial limit for one of your
          products, you must acquire a Full Commercial License.
        
          If you contribute to the source code, documentation, or related materials,
          you must grant me an exclusive license to these contributions.
          Contributions are governed by the "Contributions" section of the General
          License Agreement.
        
          Copying the work in parts is strictly forbidden, except as permitted
          under the General License Agreement.
        
          If you do not or cannot agree to the terms of this Agreement,
          do not use this work.
        
          This work is provided "as is", without any warranties, express or implied,
          except where such disclaimers are legally invalid.
        
          Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
          All rights reserved.
        ------------------------------------------------------------------------------->
        
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap"
            rel="stylesheet"
        />
        <script src="extra/libs/highlight.min.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/customization.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "adastra-theme" : "adastra-theme";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('adastra-theme')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="playground.html">Playground</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="user-guide/syntax-overview.html">Syntax Overview</a></li><li class="chapter-item expanded "><a href="user-guide/control-flow.html">Control Flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user-guide/control-flow/variables.html">Variables</a></li><li class="chapter-item expanded "><a href="user-guide/control-flow/expression-statements.html">Expression Statements</a></li><li class="chapter-item expanded "><a href="user-guide/control-flow/nested-blocks.html">Nested Blocks</a></li><li class="chapter-item expanded "><a href="user-guide/control-flow/imports.html">Imports</a></li><li class="chapter-item expanded "><a href="user-guide/control-flow/loop-statements.html">Loop Statements</a></li><li class="chapter-item expanded "><a href="user-guide/control-flow/conditional-branching.html">Conditional Branching</a></li><li class="chapter-item expanded "><a href="user-guide/control-flow/returning-statements.html">Returning Statements</a></li></ol></li><li class="chapter-item expanded "><a href="user-guide/expressions.html">Expressions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user-guide/expressions/operators-priority.html">Operators Priority</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/arrays.html">Arrays</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/nil-data.html">Nil Data</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/strings.html">Strings</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/numbers.html">Numbers</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/booleans.html">Booleans</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/ranges.html">Ranges</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/functions.html">Functions</a></li><li class="chapter-item expanded "><a href="user-guide/expressions/structures.html">Structures</a></li></ol></li><li class="chapter-item expanded "><a href="user-guide/mutability.html">Mutability</a></li><li class="chapter-item expanded "><a href="user-guide/type-system.html">Type System</a></li><li class="chapter-item expanded "><a href="user-guide/memory-model.html">Memory Model</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Developer Guide</li><li class="chapter-item expanded "><a href="developer-guide/api-overview.html">API Overview</a></li><li class="chapter-item expanded "><a href="developer-guide/exporting.html">Exporting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developer-guide/exporting/script-packages.html">Script Packages</a></li><li class="chapter-item expanded "><a href="developer-guide/exporting/functions.html">Functions</a></li><li class="chapter-item expanded "><a href="developer-guide/exporting/structs.html">Structs</a></li><li class="chapter-item expanded "><a href="developer-guide/exporting/operators.html">Operators</a></li><li class="chapter-item expanded "><a href="developer-guide/exporting/comments.html">Comments</a></li><li class="chapter-item expanded "><a href="developer-guide/exporting/statics-and-consts.html">Statics and Consts</a></li><li class="chapter-item expanded "><a href="developer-guide/exporting/advanced-export.html">Advanced Export</a></li></ol></li><li class="chapter-item expanded "><a href="developer-guide/analysis.html">Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developer-guide/analysis/access-guards.html">Access Guards</a></li><li class="chapter-item expanded "><a href="developer-guide/analysis/module-text.html">Module Text</a></li><li class="chapter-item expanded "><a href="developer-guide/analysis/diagnostics.html">Diagnostics</a></li><li class="chapter-item expanded "><a href="developer-guide/analysis/editing.html">Editing</a></li><li class="chapter-item expanded "><a href="developer-guide/analysis/advanced-analysis.html">Advanced Analysis</a></li></ol></li><li class="chapter-item expanded "><a href="developer-guide/evaluation.html">Evaluation</a></li><li class="chapter-item expanded "><a href="developer-guide/language-server.html">Language Server</a></li><li class="chapter-item expanded "><a href="developer-guide/web-assembly.html">Web Assembly</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">The Ad Astra Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Eliah-Lakhin/ad-astra" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<img align="right" height="160" style="float: right; margin-left: 10px; width: 160px" alt="Ad Astra Logo" src="https://raw.githubusercontent.com/Eliah-Lakhin/ad-astra/master/work/logo.png" />
<p>Ad Astra is a configurable scripting language designed primarily for embedded
use in Rust applications.</p>
<p>The language features an easy-to-learn, minimalistic syntax that should feel
familiar to users of JavaScript or Python. Developers can expose parts of their
host Rust crate APIs — such as functions, types, type methods, and operators on
types — to the script environment. These APIs collectively form a
domain-specific customization of Ad Astra, enabling the end user to interact
with the Rust application at runtime in a fully dynamic way.</p>
<h2 id="built-in-language-server"><a class="header" href="#built-in-language-server">Built-in Language Server</a></h2>
<p>Usability is one of the key design goals of Ad Astra.</p>
<p>Ad Astra offers a full-featured LSP (Language Server Protocol) server that
supports a wide range of editor features, such as code completions, type
hints, symbol references, and more.</p>
<p>Through the editor environment, users can explore the exported domain-specific
APIs. The user-facing documentation for these APIs mirrors the RustDoc
documentation of the original exported Rust APIs. Overall, the language server
aims to provide the script user with an experience on par with RustAnalyzer.</p>
<p>You can try the language server features in the <a href="playground.html">Ad Astra Playground</a>, a
static web application with the LSP server running in a local web worker.</p>
<p><a href="playground.html"><img src="https://raw.githubusercontent.com/Eliah-Lakhin/ad-astra/master/work/showcase.gif" alt="Showcase" /></a></p>
<h2 id="exporting"><a class="header" href="#exporting">Exporting</a></h2>
<p>Rust programmers can export Rust APIs directly to the script environment by
annotating the corresponding APIs with the Export attribute macro.</p>
<p>In most cases, developers don't need to maintain an extra abstraction layer
between the Rust static APIs and the fully dynamic script runtime. The export
system automatically performs all necessary Rust code introspections and
exporting. However, the Ad Astra crate also provides low-level exporting
components for fine-grained export edge cases.</p>
<pre><code class="language-rust">#[export]
pub fn deg(degrees: f64) -&gt; f64 {
    PI * degrees / 180.0
}

#[export]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Vector {
    pub x: f64,
    pub y: f64,
}

#[export]
impl Add for Vector {
    type Output = Self;

    fn add(mut self, rhs: Self) -&gt; Self::Output {
        self.x += rhs.x;
        self.y += rhs.y;

        self
    }
}

#[export]
impl Vector {
    pub fn radius(&amp;self) -&gt; f64 {
        (self.x * self.x + self.y * self.y).sqrt()
    }
}</code></pre>
<h2 id="book"><a class="header" href="#book">Book</a></h2>
<p>The User Guide sections of this book describe the base language syntax and
semantics.</p>
<p>The Developer Guide is a tutorial that walks you through the Ad Astra exporting
system, as well as the compiler and language server setup steps.</p>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="https://github.com/Eliah-Lakhin/ad-astra">GitHub Repository</a></li>
<li><a href="https://docs.rs/ad-astra">API Documentation</a></li>
<li><a href="https://crates.io/crates/ad-astra">Main Crate</a></li>
<li><a href="https://ad-astra.lakhin.com">Guide Book</a></li>
<li><a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples">Examples</a></li>
<li><a href="https://ad-astra.lakhin.com/playground.html">Playground</a></li>
</ul>
<h2 id="copyright"><a class="header" href="#copyright">Copyright</a></h2>
<p>This work is proprietary software with source-available code.</p>
<p>To copy, use, distribute, or contribute to this work, you must agree to the
terms and conditions of the <a href="https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md">General License Agreement</a>.</p>
<p>For an explanation of the licensing terms, see the
<a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/FAQ.md">F.A.Q.</a></p>
<p>Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин). All rights reserved.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<style>
html.adastra-theme {
    --content-max-width: 950px;
}

#example-select {
    background: #e0e0e0;
    border: none;
    font-size: 16px;
    font-weight: bold;
    padding: 5px;
}

#example-select option {
    font-size: 18px;
}

#example-select:focus {
    outline: none;
}

#loading {
    visibility: visible;
    opacity: 1;
}

#loading.loading-visible {
    visibility: visible;
    opacity: 1;
    transition: visibility 0s 100ms, opacity 250ms linear;
}

#loading.loading-hidden {
    visibility: hidden;
    opacity: 0;
    transition: visibility 0s 250ms, opacity 250ms linear;
}
</style>
<script
    src="extra/libs/require.min.js"
    data-main="extra/playground"
></script>
<h1 id="playground"><a class="header" href="#playground">Playground</a></h1>
<div style="display: flex; flex-direction: column; height: 80vh;">
    <div style="
        padding: 2px 10px;
        background: #e0e0e0;
        border-radius: 10px 10px 0 0;
        border-style: solid;
        border-color: #b3b6b7;
        border-width: 1px 1px 0 1px;
    ">
        <label style="display: flex;">
            <select id="example-select" style="flex-grow: 1" disabled>
                <option value="algebra" selected>Algebra — Using Rust API from scripts</option>
                <option value="collatz">Collatz — Control flow constructions</option>
                <option value="mutability">Mutability — Passing by reference</option>
                <option value="closures">Closures — Functions are first-order objects</option>
                <option value="structs">OOP — Script structs with fields and methods</option>
                <option value="quicksort">Quicksort — Functions recursion</option>
            </select>
        </label>
    </div>
    <div
        id="editor-container"
        style="
            position: relative;
            padding: 0;
            flex: 1;
            background: #424949;
            border-style: solid;
            border-color: #b3b6b7;
            border-width: 1px 1px 0 1px;
        "
    >
        <div
            id="loading"
            class="loading-visible"
            style="
                position: absolute;
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
                background-color:rgba(66, 73, 73, 0.85);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1;
            "
        >
            <div style="
                min-width: 250px;
                padding: 0;
            ">
                <div style="
                    background: #e0e0e0;
                    border-radius: 10px 10px 0 0;
                    border-style: solid;
                    border-color: #b3b6b7;
                    border-width: 1px 1px 0 1px;
                    font-size: 1.1em;
                    font-weight: bold;
                    text-align: center;
                    padding: 5px 0;
                ">Loading...</div>
                <ul style="
                    list-style: none;
                    padding: 20px;
                    margin: 0;
                    background: #b3b6b7;
                    border-color: #b3b6b7;
                    border-radius: 0 0 10px 10px;
                    border-style: solid;
                    border-width: 0 1px 1px 1px;
                ">
                    <li>
                        <i
                            id="loading-client"
                            class="fa fa-check"
                            aria-hidden="true"
                            style="visibility: hidden; color: #229954; margin-right: 5px;"
                        ></i>
                        Language Client
                    </li>
                    <li>
                        <i
                            id="loading-server"
                            class="fa fa-check"
                            aria-hidden="true"
                            style="visibility: hidden; color: #229954; margin-right: 5px;"
                        ></i>
                        Language Server <span id="loading-server-progress"></span>
                    </li>
                    <li>
                        <i
                            id="loading-example"
                            class="fa fa-check"
                            aria-hidden="true"
                            style="visibility: hidden; color: #229954; margin-right: 5px;"
                        ></i>
                        Example File <span id="loading-example-progress"></span>
                    </li>
                </ul>
            </div>
        </div>
        <div
            id="editor"
            style="
                position: absolute;
                width: 100%;
                height: 100%;
                padding: 0;
                background: #424949;
            "
        ></div>
    </div>
    <div style="padding: 0; margin: 0; display: flex; width: 100%;;">
        <div style="
            background: #e0e0e0;
            display: flex;
            flex-direction: column;
            border-radius: 0 0 0 10px;
            border-style: solid;
            border-color: #b3b6b7;
            border-width: 0 0 1px 1px;
        ">
            <div style="display: flex; flex-direction: column; flex-grow: 1;">
                <button
                    id="editor-launch-btn"
                    title="Run Script"
                    style="
                        padding: 0;
                        margin: 0;
                        width: 50px;
                        height: 50px;
                        font-size: 2.25em;
                        color: #229954;
                        background: none;
                        border: none;
                    "
                >
                    <i class="fa fa-play"></i>
                </button>
                <button
                    id="editor-stop-btn"
                    title="Stop Script Evaluation"
                    style="
                        display: none;
                        padding: 0;
                        margin: 0;
                        width: 50px;
                        height: 50px;
                        font-size: 2.25em;
                        color: #ba4a00;
                        background: none;
                        border: none;
                    "
                >
                    <i class="fa fa-stop"></i>
                </button>
                <button
                    id="editor-cleanup-btn"
                    title="Cleanup Debug Messages"
                    style="
                        display: none;
                        padding: 0;
                        margin: 0;
                        width: 50px;
                        height: 50px;
                        font-size: 2.25em;
                        color: #d4ac0d;
                        background: none;
                        border: none;
                    "
                >
                    <i class="fa fa-refresh"></i>
                </button>
            </div>
            <div style="display: flex; flex-direction: column;">
                <button
                    id="editor-hints-btn"
                    title="Show Extra Hints"
                    style="
                        padding: 0;
                        margin: 0;
                        width: 50px;
                        height: 50px;
                        font-size: 2.25em;
                        color: #b3b6b7;
                        background: none;
                        border: none;
                    "
                >
                    <i class="fa fa-commenting-o"></i>
                </button>
            </div>
        </div>
        <code
            id="editor-console"
            class="language-adastra-console"
            style="
                padding: 10px;
                margin: 0;
                flex: 1;
                border: 0 !important;
                border-radius: 0 0 10px 0;
                background: #b3b6b7;
                color: #000;
                height: 160px;
                overflow: auto;
                white-space: nowrap;
            "
        >
        <div style="color: #626567;">
            Shortcuts:<br/>
            - Pressing Ctrl+S in the editor formats the code.<br/>
            - Pressing Ctrl+Space opens the code completion menu.<br/>
            - Pressing Ctrl+Click on a variable or field jumps to its definition.<br/>
            - Press F2 on a variable or field to rename it.<br/>
        </div>
        </code>
    </div>
</div>
<h2 id="exported-rust-module"><a class="header" href="#exported-rust-module">Exported Rust Module</a></h2>
<p>The source code above can use exported constructions from Rust's
<a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/exporting/src/lib.rs">algebra.rs</a>
module via the script's <code>use algebra;</code> import statement.</p>
<pre><code class="language-rust ignore">use std::{
    f64::consts::PI,
    fmt::{Display, Formatter},
    ops::{Add, Mul, Neg},
};

use ad_astra::export;

/// An example package with basic 2D coordinate system transformation features.
#[export(package)]
#[derive(Default)]
struct Package;

/// Converts degrees to radians.
#[export]
pub fn deg(degrees: f64) -&gt; f64 {
    PI * degrees / 180.0
}

/// Converts radians to degrees.
#[export]
pub fn rad(radians: f64) -&gt; f64 {
    180.0 * radians / PI
}

/// Rounds a floating-point number up to the nearest integer.
#[export]
pub fn round(value: f64) -&gt; i64 {
    value.round() as i64
}

/// A 2D vector.
#[export]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Vector {
    /// The x-coordinate of the vector.
    pub x: f64,

    /// The y-coordinate of the vector.
    pub y: f64,
}

#[export]
impl Neg for Vector {
    type Output = Self;

    fn neg(mut self) -&gt; Self::Output {
        self.x = -self.x;
        self.y = -self.y;

        self
    }
}

#[export]
impl Add for Vector {
    type Output = Self;

    fn add(mut self, rhs: Self) -&gt; Self::Output {
        self.x += rhs.x;
        self.y += rhs.y;

        self
    }
}

#[export]
impl Display for Vector {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_fmt(format_args!("vec({}, {})", self.x, self.y))
    }
}

#[export]
impl Vector {
    /// Constructs a new 2D vector.
    #[export(name "vec")]
    pub fn new(x: f64, y: f64) -&gt; Self {
        Self { x, y }
    }

    /// Returns the magnitude (or length) of the vector.
    pub fn radius(&amp;self) -&gt; f64 {
        (self.x * self.x + self.y * self.y).sqrt()
    }

    /// Returns the angle of the vector in the 2D coordinate system.
    pub fn angle(&amp;self) -&gt; f64 {
        self.y.atan2(self.x)
    }

    /// Normalizes this vector by setting its magnitude to 1 while preserving
    /// the original angle.
    pub fn normalize(&amp;mut self) -&gt; &amp;mut Self {
        let r = self.radius();

        self.x /= r;
        self.y /= r;

        self
    }

    /// Transforms this vector using the provided transformation matrix.
    pub fn transform(&amp;mut self, matrix: &amp;Matrix) -&gt; &amp;mut Self {
        let x = matrix.x.x * self.x + matrix.x.y * self.y;
        let y = matrix.y.x * self.x + matrix.y.y * self.y;

        self.x = x;
        self.y = y;

        self
    }
}

/// A 2x2 transformation matrix.
#[export]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Matrix {
    x: Vector,
    y: Vector,
}

#[export]
impl Mul for Matrix {
    type Output = Self;

    fn mul(self, rhs: Matrix) -&gt; Self::Output {
        Self {
            x: Vector {
                x: self.x.x * rhs.x.x + self.x.y * rhs.y.x,
                y: self.x.x * rhs.x.y + self.x.y * rhs.y.y,
            },
            y: Vector {
                x: self.y.x * rhs.x.x + self.y.y * rhs.y.x,
                y: self.y.x * rhs.x.y + self.y.y * rhs.y.y,
            },
        }
    }
}

#[export]
impl Matrix {
    /// Creates a 2x2 transformation matrix that rotates the coordinate system
    /// by the specified angle in radians.
    pub fn rotation(angle: f64) -&gt; Self {
        let (sin, cos) = angle.sin_cos();

        Self {
            x: Vector { x: cos, y: -sin },
            y: Vector { x: sin, y: cos },
        }
    }

    /// Computes the determinant of this matrix.
    pub fn det(&amp;self) -&gt; f64 {
        self.x.x * self.y.y - self.x.y * self.y.x
    }

    /// Constructs a new matrix that is the inverse of this one.
    pub fn invert(&amp;self) -&gt; Self {
        let det = self.det();

        Self {
            x: Vector {
                x: self.y.y / det,
                y: -self.x.y / det,
            },
            y: Vector {
                x: -self.y.x / det,
                y: self.x.x / det,
            },
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="syntax-overview"><a class="header" href="#syntax-overview">Syntax Overview</a></h1>
<p>Ad Astra is a dynamically typed imperative scripting language with elements of
functional and concatenative programming paradigms.</p>
<p>The base semantics of the language is similar to JavaScript: a typical script
consists of anonymous functions and structural objects that form the program's
design.</p>
<pre><code class="language-adastra">let my_object = struct {
    field: 10,
    method: fn(param) {
        self.field += param;
    },
};

my_object.method(20);

my_object.field == 30;
</code></pre>
<p>Visually, the language attempts to mimic Rust's syntax: variables are introduced
with the <code>let</code> keyword, objects with the <code>struct</code> keyword, functions with the
<code>fn</code> keyword, and so on.</p>
<p>In general, Ad Astra is a dynamically typed language, meaning that variable and
expression types are inferred during script evaluation. However, there are
certain static restrictions imposed on language constructs. For instance, you
cannot change the type of a variable once it has been assigned a value, nor can
you invoke a function with an arbitrary number of arguments.</p>
<pre><code class="language-adastra">let x = 10;

x = 20; // But you cannot assign a string literal to `x`.
</code></pre>
<p>These restrictions make the code architecture less ambiguous than, for example,
JavaScript or Python programs. At the same time, they make static source code
analysis more predictable within local evaluation contexts.</p>
<p>The primary source of program polymorphism is user-defined functions. A function
introduced by the user does not impose restrictions on input parameter types or
the output type. Essentially, all script-defined functions are polymorphic.</p>
<pre><code class="language-adastra">let concat_two_args = fn(a, b) {
    return [a, b];
};

concat_two_args(10, 20); // Creates an array of numbers: [10, 20].

concat_two_args("hello ", "world"); // Creates a new string: "hello world".
</code></pre>
<p>In contrast, the APIs exported from Rust have well-defined typed signatures.</p>
<p>For example, if you have a Rust function <code>fn deg_to_rad(x: f64) -&gt; f64</code>, you
cannot call this function in scripts by providing a <code>struct</code> argument. Doing so
would result in a runtime error, and the static analyzer will detect such misuse
in most cases.</p>
<p>Finally, the script user cannot introduce new types or operators on the types.
All types and the operations on them (including type methods) are exported from
Rust to the script, defining the domain-specific environment for the script code.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>The script code is the body of an implicit function with zero parameters, which
serves as the entry point of the script.</p>
<p>The body of a function (including the entry-point code) consists of statements
that are executed sequentially, except for control flow statements such as loops
and conditionals.</p>
<pre><code class="language-adastra">// Injects additional APIs from the sub-package "algebra"
// into the current namespace.
use algebra;

let x = 10; // Variable declaration.

foo(x + 20); // Expression statement.

// Simple conditional statement.
if x == 10 {
    do_something();
}

// Complex conditional statement.
match x {
    10 =&gt; {},
    20 =&gt; {},
    else =&gt; {},
}

// Infinite loop statement.
loop {
    x += 1;
    
    if x &gt; 10 {
        break; // Breaks the loop.
    }
}

// For loop that iterates through the numeric range from 10 to 19 inclusive.
for i in 10..20 {
    dbg(i);
}

// Nested statement block.
{
    let inner_var;
    func_1();
    func_2();
}

// Returning from a function (from the script's main function in this case).
return "end";
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<pre><code class="language-adastra">let x = 10;
let y;

y = 10;
</code></pre>
<p>Variable introduction starts with the <code>let</code> keyword, followed by the variable
name, and ends with a semicolon (<code>;</code>).</p>
<p>The optional <code>= 10</code> part initializes the variable immediately with the provided
expression. You can delay a variable's initialization (as in the case of the <code>y</code>
variable), but you cannot use an uninitialized variable until it is fully
initialized.</p>
<pre><code class="language-adastra">let x;

if something() {
    x = 10;
    
    // The variable `x` is considered fully initialized here, and you can use it.
}

// However, outside of the condition's block, the variable `x` might be
// uninitialized.

let y;

match something() {
    true =&gt; { y = 10; }
    false =&gt; { y = 20; }
}

// The variable `y` is fully initialized here because the `match`
// statement covers all possible control-flow branches.
</code></pre>
<p>You can use any Ad Astra identifier as a variable name, which is a sequence of
alphanumeric and "_" ASCII characters. Note that Ad Astra currently does not
support arbitrary Unicode identifiers.</p>
<p>Variables allow users to introduce new functions and structure instances in the
code. In Ad Astra, structures and functions are anonymous, and by assigning them
to variables, users create "named" functions and structures.</p>
<pre><code class="language-adastra">let sum = fn(x, y) {
    return x + y;
};

let st = struct { field: 10 };

st.field = sum(10, 20);
</code></pre>
<h2 id="identifier-shadowing"><a class="header" href="#identifier-shadowing">Identifier Shadowing</a></h2>
<p>A variable introduction statement shadows any identifier with the same name that
was previously introduced in the scope.</p>
<pre><code class="language-adastra">let x = 10;
let x = 20; // Shadows the previously introduced `x`.

{
    let x = 30; // Shadows the previous `x`, but only within the block context.
    
    x == 30;
}

x == 20;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="expression-statements"><a class="header" href="#expression-statements">Expression Statements</a></h1>
<p>An expression statement is any Ad Astra expression that ends with a semicolon (<code>;</code>).</p>
<pre><code class="language-adastra">(10 + 20) * (30 + foo(40));
</code></pre>
<p>Note that, unlike in Rust, Ad Astra statements are not expressions. The following
syntax is not allowed: <code>return match x { 10 =&gt; true, else =&gt; false};</code>.</p>
<h2 id="variable-initialization-statement"><a class="header" href="#variable-initialization-statement">Variable Initialization Statement</a></h2>
<p>The engine interprets the <code>&lt;variable_name&gt; = &lt;expr&gt;;</code> assignment syntax as a
special expression statement that initializes the variable if it is not yet
initialized. Otherwise, it treats this expression as a standard assignment
operation.</p>
<p>Note that you cannot initialize uninitialized variables in any other way. Inner
assignment expressions will also be interpreted as assignment operations.</p>
<pre><code class="language-adastra">let x;

// This will not initialize variable x:
// foo(x = 10);

// But this expression is an initialization expression.
x = 10;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="nested-blocks"><a class="header" href="#nested-blocks">Nested Blocks</a></h1>
<p>You can introduce nested code blocks, for example, if you want to limit the
scope of a variable.</p>
<pre><code class="language-adastra">let x = 10;

{   
    let y = 30;
    
    x = y;
}

x == 30;

// The variable `y` is inaccessible here.
</code></pre>
<p>In contrast to JavaScript, variables introduced within the nearest local
namespace context (e.g., a code block) exist only until the end of that
context.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="import-statements"><a class="header" href="#import-statements">Import Statements</a></h1>
<p>If the script environment includes additional packages through which the host
system exports extra APIs (such as Rust functions or constants), the script can
inject these API identifiers into the current namespace scope using the
<code>use &lt;package&gt;;</code> statement.</p>
<pre><code class="language-adastra">use algebra;

// Calls the function "vec" from the imported package "algebra".
let v = vec(0.0, 1.0);
</code></pre>
<p>By importing identifiers from a package, they shadow any previously introduced
identifiers, similar to variable shadowing.</p>
<pre><code class="language-adastra">let vec = 10;

{
    use algebra;
    
    vec(0.0, 1.0); // Refers to the "algebra.vec" function.
}

// Outside of the block, the original `vec` variable is no longer shadowed.
vec == 10;
</code></pre>
<p>Note that you can refer to package identifiers directly without importing them.
Additionally, you can always refer to the current package using the built-in
<code>crate</code> identifier, which cannot be shadowed.</p>
<pre><code class="language-adastra">let vec = 10;

algebra.vec(0.0, 1.0);

let algebra = 20;

crate.algebra.vec(0.0, 1.0);

// Since the "algebra" package is shadowed by the `algebra` variable, you can
// import this package using the `crate` built-in identifier.
use crate.algebra;

// Refers to the "algebra.vec" function.
vec(0.0, 1.0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="loop-statements"><a class="header" href="#loop-statements">Loop Statements</a></h1>
<p>There are two loop constructs: an unlimited loop and a for-iterator loop.</p>
<pre><code class="language-adastra">let i = 1;
// Repeats the code block an unlimited number of times until
// a break statement is encountered.
loop {
    if i &gt;= 100 {
        break;
    }
    
    dbg(i);

    i += 1;
}

// Repeats the block for each numeric value in the range,
// or until the loop is explicitly broken.
for i in 1..100 {
    dbg(i);
}
</code></pre>
<p>The loop statement repeats the code block indefinitely until the program
encounters a <code>break;</code> statement.</p>
<p>The for-iterator introduces a new integer variable (specified before the <code>in</code>
keyword), which iterates through every numeric value within the range expression
(specified after the <code>in</code> keyword).</p>
<p>The range expression can be any Ad Astra expression that returns a numeric
range. In the example above, the script will enter a code block with the <code>i</code>
numeric variable iterating from 1 to 99 inclusive. This variable is accessible
only within the body of the for-loop block (and all nested code within that
block).</p>
<h2 id="breaking-and-continuation"><a class="header" href="#breaking-and-continuation">Breaking and Continuation</a></h2>
<p>Within the body of loop and for-iterator statements, the code can invoke
<code>break;</code> and <code>continue;</code> statements.</p>
<p>The <code>break;</code> statement immediately ends the loop's execution, while the
<code>continue;</code> statement skips the remaining code in the current iteration and
moves on to the next iteration.</p>
<pre><code class="language-adastra">let i = 0;
loop {
    if i &gt;= 10 {
        break;
    }
    
    if i % 2 == 0 {
        continue;
    }
    
    // Prints 1, 3, 5, 7, 9
    dbg(i);

    i += 1;
}
</code></pre>
<p>Note that loop control statements affect the nearest loop in which the statement
is nested. If a loop is nested within another loop, breaking the inner loop will
cause the outer loop to continue its execution.</p>
<pre><code class="language-adastra">loop {
    loop {
        break; // Exits the inner loop.
    }
    
    break; // Exits the outer loop.
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="conditional-branching"><a class="header" href="#conditional-branching">Conditional Branching</a></h1>
<p>Ad Astra provides two conditional statements that control the flow of execution
based on a conditional expression: the simple single-branching <code>if</code> statement
and the multi-branching <code>match</code> statement.</p>
<h2 id="if-statement"><a class="header" href="#if-statement">If Statement</a></h2>
<pre><code class="language-adastra">if 20 &gt; 10 {
    // Body
}
</code></pre>
<p>The if-statement evaluates the provided expression to a boolean value. If the
value is <code>true</code>, the body block will be executed; otherwise, the block will be
skipped.</p>
<p>In Ad Astra, if statements do not have "else" branches
(e.g., <code>if foo {} else {}</code> syntax is <strong>forbidden</strong>). For multi-branching logic,
you should use match statements instead.</p>
<h2 id="match-statement"><a class="header" href="#match-statement">Match Statement</a></h2>
<p>In Ad Astra, the multi-branching match statement serves the purpose of
"switching" conditional branching, and it comes in two forms: a match statement
with a subject and a match statement without a subject.</p>
<pre><code class="language-adastra">match subject {
    10 =&gt; {},
    20 =&gt; {},
    else =&gt; {},
}

match {
    foo &gt; 10 =&gt; {},
    bar &lt; 20 =&gt; {},
    else =&gt; {},
}
</code></pre>
<p>The body of the match statement (the code enclosed in <code>{...}</code> curly braces)
consists of match arms. Each arm contains a testing <em>expression</em> specified
before the <code>=&gt;</code> arrow and an arm <em>body</em> specified after the arrow.</p>
<p>Match arms are separated by <code>,</code> commas, with an optional trailing comma. If the
arm's body is a code block, the comma separator can be omitted.</p>
<p>As the body, the user can specify either a code block or an expression, which
will be interpreted as a block with a single expression statement.</p>
<p>The script engine executes match arms one by one in the order they are
specified.</p>
<p>If the match statement has a subject expression, the engine tests for equality
between the subject value and the arm's expression. If the statement does not
have a subject, the engine interprets the arm's expression as a boolean.</p>
<p>Once the engine finds the first truthful arm, it executes its body and ends the
match statement.</p>
<p>For example, an "if-else" branching could be expressed as follows:</p>
<pre><code class="language-adastra">match foo &gt; 10 {
    true =&gt; dbg("foo is greater than 10"),
    false =&gt; dbg("foo is less than or equal to 10"),
}
</code></pre>
<p>The "switch" branching could be expressed as follows:</p>
<pre><code class="language-adastra">match foo {
    2 =&gt; dbg("foo is equal to 2"),
    7 =&gt; dbg("foo is equal to 7"),
    else =&gt;  dbg("foo is neither 2 nor 7"),
}
</code></pre>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>Exhaustiveness means that the conditional branching covers all possible
conditions.</p>
<p>The <code>if</code> statement is never exhaustive unless the conditional expression is a
trivial <code>true</code> or <code>false</code> literal, because this statement does not have a
fallback "else" case.</p>
<p>The <code>match</code> statement can be exhaustive if it covers all possibilities.
For example, if the statement has match arms covering both <code>true</code> and <code>false</code>
values.</p>
<p>To make the match branching explicitly exhaustive, you can introduce a special
fallback arm: <code>else =&gt; {}</code> (the "else" keyword is a built-in construct).</p>
<p>This fallback arm should be the last one in the list of match arms, and it will
be executed as the final option if all previous conditions fail.</p>
<h2 id="variable-initialization"><a class="header" href="#variable-initialization">Variable Initialization</a></h2>
<p>You can conditionally initialize a variable using an <em>exhaustive</em> match
statement.</p>
<pre><code class="language-adastra">let x;

match foo {
    "bar" =&gt; x = 10,
    "baz" =&gt; x = 20,
    else =&gt; x = 30,
}

// Variable `x` is fully initialized here.

dbg(x);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="returning-statements"><a class="header" href="#returning-statements">Returning Statements</a></h1>
<p>The <code>return;</code> and <code>return &lt;expr&gt;;</code> statements immediately stop the current
function's execution and return the provided expression as the function's
result. The variant without an expression returns a <em>nil</em> value from the
function. If the function reaches its end without an explicit return, it returns
a <em>nil</em> value implicitly.</p>
<pre><code class="language-adastra">let foo = fn() {
    // Returns the value 100 from the foo function.
    return 100;
};

let one_hundred = foo();

// Returns the value 200 from the script.
return one_hundred * 2;
</code></pre>
<p>Depending on the Ad Astra specialization, the value returned from the script may
represent the result of the script's execution.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>Expressions in Ad Astra are constructs that compute data values.</p>
<p>Expressions are distinct from control-flow statements. Unlike in Rust, Ad Astra
statements are not expressions and do not produce any values.</p>
<p>An expression is any combination of atomic operands and operators applied to
other expressions:</p>
<ul>
<li>
<p><strong>Literals</strong>:</p>
<ul>
<li>
<p>Integer literals: <code>100</code>, <code>200</code>.</p>
</li>
<li>
<p>Float literals: <code>10.5</code>, <code>0.1234e-6</code>.</p>
</li>
<li>
<p>Unicode string literals: <code>"foo"</code>, <code>"abra cadabra"</code>.</p>
</li>
<li>
<p>Boolean literals: <code>true</code>, <code>false</code>.</p>
</li>
<li>
<p>Nil type constructor: <code>[]</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Identifiers</strong>:</p>
<ul>
<li>
<p>A normal variable, function argument, or exported symbol identifier: <code>foo</code>.</p>
</li>
<li>
<p>Built-in context variable: <code>self</code>.</p>
<p>Under <code>struct</code> method functions, this variable refers to the struct object
instance, but in general, it could refer to any object depending on the
Ad Astra specialization that describes the function's calling context.
By default (and unless the function is a struct method), <code>self</code> is a <em>nil</em>
value.</p>
</li>
<li>
<p>Built-in current package reference: <code>crate</code>.</p>
<p>This identifier always points to the script package under which the script
code is being evaluated. For example, if you have a variable "foo" that
shadows a function "foo" from the current package, you can always call the
package function using the <code>crate</code> identifier: <code>crate.foo()</code>.</p>
</li>
<li>
<p>Built-in maximum constant: <code>max</code>.</p>
<p>This constant evaluates to the maximum unsigned integer number and is useful
for the unbound range construct: <code>10..max</code> (all numbers from 10 to "infinity").</p>
</li>
</ul>
</li>
<li>
<p><strong>Binary operators</strong> such as <code>&lt;left_operand&gt; &lt;op&gt; &lt;right_operand&gt;</code>, where the
left and right operands are any expressions, and the operator between them is
any of the following:</p>
<ul>
<li>
<p>Assignment operators: <code>foo = bar</code>.</p>
</li>
<li>
<p>Arithmetic operators: <code>foo + bar</code>, <code>foo - bar</code>, <code>foo * bar</code>, <code>foo / bar</code>,
<code>foo % bar</code>.</p>
</li>
<li>
<p>Bitwise operators: <code>foo &amp; bar</code>, <code>foo | bar</code>, <code>foo ^ bar</code>, <code>foo &lt;&lt; bar</code>,
<code>foo &gt;&gt; bar</code>.</p>
</li>
<li>
<p>Logical operators: <code>foo &amp;&amp; bar</code>, <code>foo || bar</code>.</p>
</li>
<li>
<p>Composite assignments: <code>foo += bar</code>, <code>foo -= bar</code>, <code>foo *= bar</code>,
<code>foo /= bar</code>, <code>foo &amp;= bar</code>, <code>foo |= bar</code>, <code>foo ^= bar</code>, <code>foo &lt;&lt;= bar</code>,
<code>foo &gt;&gt;= bar</code>, <code>foo %= bar</code>.</p>
<p>These operators usually perform the corresponding binary operation on the
operands and then assign the result to the left-hand operand.</p>
<p>Note that <code>&amp;&amp;=</code> and <code>||=</code> are not supported.</p>
</li>
<li>
<p>Equality operators: <code>foo == bar</code>, <code>foo != bar</code>.</p>
</li>
<li>
<p>Ordering operators: <code>foo &gt; bar</code>, <code>foo &gt;= bar</code>, <code>foo &lt; bar</code>, <code>foo &lt;= bar</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Unary operators</strong>:</p>
<ul>
<li>
<p>Copy operator: <code>*&lt;expr&gt;</code>.</p>
<p>This is a built-in operator that creates a clone of the underlying operand.
For example, <code>*"hello world"</code> creates a copy of a string.</p>
</li>
<li>
<p>Nil testing operator: <code>&lt;expr&gt;?</code>.</p>
<p>Another built-in operator that tests if the operand is a <em>nil</em> value or of
a void-like type.</p>
</li>
<li>
<p>Numeric negation: <code>-&lt;expr&gt;</code>.</p>
</li>
<li>
<p>Logical negation: <code>!&lt;expr&gt;</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Array Constructor</strong>: <code>[a, b, c]</code>.</p>
</li>
<li>
<p><strong>Array Length</strong>: <code>my_array.len</code>.</p>
</li>
<li>
<p><strong>Array Index</strong>: <code>foo[index]</code>, where <code>index</code> is a numeric unsigned integer
value or a range (e.g., <code>10..20</code>).</p>
<p>In the case of ranges, the operator returns a slice of the <code>foo</code> array that
spans a sequence of the original array within the specified range.
For example, <code>[10, 20, 30, 40][1..3]</code> evaluates to the array <code>[20, 30]</code>.</p>
</li>
<li>
<p><strong>Range Constructor</strong>: <code>start..end</code>, where <code>start</code> and <code>end</code> are any unsigned
integer values.</p>
<p>The constructed range object specifies indices starting from the <code>start</code> value
(inclusive) up until the <code>end</code> value (exclusive). The <code>3..5</code> range means
indices 3 and 4. The end bound must be greater than or equal to the start
bound; otherwise, the range is invalid, which will result in runtime errors
in most cases.</p>
</li>
<li>
<p><strong>Function Invocation</strong>: <code>expression(arg1, arg2, arg3)</code>.</p>
<p>This syntax can be applied to any expression value that implements Invocation.
In particular, this operator can be applied to script-defined functions and
functions exported from packages. The <code>arg1</code>, <code>arg2</code>, etc., are the argument
expressions that will be assigned to the function parameters.</p>
<p>In Ad Astra, the number of function parameters is always fixed. You cannot
invoke a function with a different number of arguments than the number of
parameters in the original function signature.</p>
</li>
<li>
<p><strong>Field Access</strong>: <code>foo.bar</code> or <code>foo.3</code>.</p>
<p>The field name could be any valid Ad Astra identifier or an integer literal.</p>
<p>Most data types (usually, most of the custom exported types) support a limited
set of predefined fields that can be accessed in scripts. The script engine
refers to these as the type's <em>components</em>. Component types are well-defined
and can be inferred at compile-time. However, some types (such as the script
structure type) support arbitrary field access semantics. In this case, field
resolution is fully dynamic.</p>
<p>The field access operator can return a data object of any arbitrary type, and
in particular, an invokable function that serves as the type's method.</p>
</li>
</ul>
<p>The majority of the above operators can be overloaded by the host (through
script engine specialization), and their meaning may vary depending on the
operand types.</p>
<p>For some built-in Ad Astra types, the specification establishes concrete,
canonical meanings and implementations for these operators. For example,
<code>10 + 20</code> is an addition of two numbers resulting in the number 30, which is
canonical for most programming languages, including Ad Astra.</p>
<p>However, for specific value types, the addition operator may have a
domain-specific meaning. For instance, adding one 3D object to another could
represent the union of those objects.</p>
<p>Overloadable operators are associated with the type of their first operand:
in the addition <code>10 + 20</code>, the operator is invoked on the numeric type (because
<code>10</code> is a numeric type). In this sense, binary operators, in general, are not
reflexive. The expression <code>10 + "20"</code> would attempt to add the number 10 and the
number 20 parsed from a string, but <code>"10" + 20</code> is illegal because the string
type does not have an addition operator.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="operators-priority"><a class="header" href="#operators-priority">Operators Priority</a></h1>
<p>Operators have precedence and, in the case of binary operators, associativity.</p>
<p>Precedence can be altered using parentheses <code>(...)</code>.</p>
<p>For example, <code>a + b + c</code> is equivalent to <code>(a + b) + c</code>.</p>
<p>In general, Ad Astra's operator precedence is similar to the rules in Rust and
many other languages with C-like syntax.</p>
<div class="table-wrapper"><table><thead><tr><th>Operators</th><th>Precedence</th><th>Associativity</th></tr></thead><tbody>
<tr><td>Assignment: <code>a = b</code>, <code>a += b</code>, etc</td><td>1</td><td>Right-to-Left</td></tr>
<tr><td>Binary disjunction: <code>a || b</code></td><td>2</td><td>Left-to-Right</td></tr>
<tr><td>Binary conjunction: <code>a &amp;&amp; b</code></td><td>3</td><td>Left-to-Right</td></tr>
<tr><td>Equality and ordering: <code>a == b</code>, <code>a &gt; b</code>, etc</td><td>4</td><td>Left-to-Right</td></tr>
<tr><td>Range operator: <code>10..20</code></td><td>5</td><td>Left-to-Right</td></tr>
<tr><td>Bitwise disjunction: <code>a | b</code></td><td>6</td><td>Left-to-Right</td></tr>
<tr><td>Bitwise exclusive disjunction: <code>a ^ b</code></td><td>7</td><td>Left-to-Right</td></tr>
<tr><td>Bitwise conjunction: <code>a &amp; b</code></td><td>8</td><td>Left-to-Right</td></tr>
<tr><td>Bitwise shift: <code>a &lt;&lt; b</code> and <code>a &gt;&gt; b</code></td><td>9</td><td>Left-to-Right</td></tr>
<tr><td>Additive: <code>a + b</code> and <code>a - b</code></td><td>10</td><td>Left-to-Right</td></tr>
<tr><td>Multiplicative: <code>a * b</code>, <code>a / b</code>, and <code>a % b</code></td><td>11</td><td>Left-to-Right</td></tr>
<tr><td>Unary Left: <code>-a</code>, <code>*a</code>, <code>!a</code></td><td>12</td><td>Left-to-Right</td></tr>
<tr><td>Unary Right: <code>a?</code>, <code>a(arg)</code>, <code>a[idx]</code>, <code>a.field</code></td><td>13</td><td>Left-to-Right</td></tr>
<tr><td>Atomic operand: <code>ident</code>, <code>crate</code>, <code>self</code>, <code>max</code></td><td>14</td><td>Left-to-Right</td></tr>
</tbody></table>
</div>
<p>Operators with a higher precedence number take priority over those with a lower
precedence number: <code>a + b * c</code> means <code>a + (b * c)</code>, because multiplicative
precedence is higher than additive.</p>
<p>Associativity indicates the typical order of operand evaluation. In the
expression <code>a = b + c</code>, the <code>b + c</code> expression is evaluated before <code>a</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>In Ad Astra, every data object is an array, usually an array with just one
element.</p>
<p>For example, the expression <code>100</code> creates an array with a single numeric value.</p>
<p>Most semantic constructions, operators, and exported functions typically create
singleton arrays (arrays with one element). Singleton arrays are convenient
operands, allowing the script code to apply operations like addition on
singletons: <code>10 + 20</code>. However, this operator is inapplicable to multi-element
arrays: <code>[10, 20] + [30, 40]</code>.</p>
<p>To create a new array, you can use the array constructor: <code>[10, 20, 30]</code>.</p>
<p>To access a single element of the array, you can use the index operator:
<code>foo[10]</code>. The index operator also accepts a range value that maps the array to
a slice: <code>foo[10..20]</code>.</p>
<p>To get the length of the array, you can use the special <code>.len</code> built-in field:
<code>[10, 20, 30].len == 3</code>.</p>
<p>Since every data object is an array, this field is available for any data object
regardless of its type: <code>10.len == 1</code>.</p>
<pre><code class="language-adastra">let my_array = [10, 20, 30, 40];

for i in 0..my_array.len {

    // Prints 10, 20, 30, and 40.
    dbg(my_array[i]);
}
</code></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>In Ad Astra, arrays are immutable in length; however, the individual elements of
an array can be mutated if the corresponding data type supports mutation.</p>
<p>For example, numeric types support mutation, so you can change the elements of
an array.</p>
<pre><code class="language-adastra">let my_array = [10, 20, 30, 40];

for i in 0..my_array.len {
    my_array[i] /= 10;

    // Prints 1, 2, 3, and 4.
    dbg(my_array[i]);
}
</code></pre>
<p>Ad Astra does not provide variable-sized arrays out of the box. Ad Astra arrays
are analogous to Rust's fixed-size arrays, which cannot be resized or reallocated.</p>
<p>For vector-like data types with dynamic resizing, the underlying engine
specialization may provide corresponding higher-level APIs.</p>
<h2 id="arrays-concatenation"><a class="header" href="#arrays-concatenation">Arrays Concatenation</a></h2>
<p>The array constructor operator <code>[a, b, c]</code> is an overloadable operator that
typically concatenates the provided arguments into a single array of elements of
the same type.</p>
<p>The implementation of this operator is type-dependent, but the canonical
implementation simply constructs a new array from the provided elements:</p>
<ul>
<li>If the argument is <em>nil</em> or an empty array, the implementation skips this
element.</li>
<li>Otherwise, the implementation attempts to cast each element of the argument's
array into a target type and adds these casted elements to the resulting
array.</li>
</ul>
<p>The expression <code>[10, 20, 30]</code> creates an array with 10, 20, and 30 numeric
values.</p>
<p>The expression <code>[[10, 20], [], [30]]</code> creates the same flat array of 10, 20,
and 30 numeric values.</p>
<p>The constructor <code>[[10]]</code> simply creates the number value 10: <code>[[10]] == 10</code>.</p>
<p>As a target data type into which each argument will be cast, the canonical
implementation uses the first non-nil argument.</p>
<p>The <code>[10, "20"]</code> constructor creates an array of numbers, attempting to parse
the second argument into a number, while the <code>["10", 20]</code> expression creates
the string "1020" because the first non-nil argument is a string. Therefore,
the rest of the arguments will be stringified as well.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="nil-data"><a class="header" href="#nil-data">Nil Data</a></h1>
<p>Ad Astra has a concept of nil data, a special object that intentionally does not
represent any value.</p>
<p>Similar concepts exist in many scripting languages such as JavaScript, Python,
nd Lua. However, in Ad Astra, nil data is less severe. For example, script code
cannot access a variable that does not exist and receive nil data. Instead, such
access would result in a hard compile-time error. Additionally, most built-in
APIs usually never accept nil data types as arguments.</p>
<p>One practical case where nil data may appear is when an exported Rust function
returns <code>Option&lt;T&gt;</code> and this option is <code>None</code>. Such a possibility should be
clear to the user because the editor displays the original Rust function
signature via the LSP server.</p>
<p>To check if a value is not nil, you can use the built-in <code>foo?</code> operator.</p>
<pre><code class="language-adastra">// fn exported_function() -&gt; Option&lt;usize&gt;
let foo = exported_function();

match foo? {
    true =&gt; dbg(foo + 10),
    false =&gt; dbg("The result is nil"),
}
</code></pre>
<p>To manually construct a nil data object, you can use an array constructor
without arguments.</p>
<pre><code class="language-adastra">[]? == false;
</code></pre>
<p>In general, it is recommended to avoid using nil data in scripts to prevent
possible "null-pointer" bugs, but this decision ultimately depends on the
script's design.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>The <code>"hello world"</code> string literal creates a string object.</p>
<p>Ad Astra strings are immutable arrays of unsigned bytes that encode Unicode
strings. These values are compatible with Rust's immutable <code>str</code> type.</p>
<p>Since strings are arrays of bytes, script code can concatenate them using the
array constructor.</p>
<pre><code class="language-adastra">["hello", " ", "world"] == "hello world";
</code></pre>
<p>The script engine interprets strings slightly differently than normal byte
arrays, considering that these arrays encode text data:</p>
<ol>
<li>
<p>The array constructor attempts to stringify each argument into a string
during the argument type casting. This feature is particularly useful for
constructing formatted strings.</p>
<pre><code class="language-adastra">let x = 10;

// Prints "The value of x is 10".
dbg(["The value of x is ", x]);
</code></pre>
</li>
<li>
<p>The string index operator indexes by the string's Unicode characters rather
than the underlying bytes.</p>
<pre><code class="language-adastra">"hello world"[1] == "e";
"hello world"[1..7] == "ello w";
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<p>The script code creates numeric objects using integral literals such as
<code>1234567</code>, and floating-point literals such as <code>123.456</code>, <code>123.456e2</code>, or
<code>123e-3</code>.</p>
<h2 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h2>
<p>For numeric types, the following operators are available:</p>
<ul>
<li>
<p>Arithmetic operations: <code>a + b</code>, <code>a - b</code>, <code>a * b</code>, <code>a / b</code>.</p>
</li>
<li>
<p>Bitwise operations (for integer numbers only): <code>a &amp; b</code>, <code>a | b</code>, <code>a ^ b</code>,
<code>a &lt;&lt; b</code>, <code>a &gt;&gt; b</code>.</p>
</li>
<li>
<p>Remainder of division (for integer numbers only): <code>a % b</code>.</p>
</li>
<li>
<p>Assignment operator: <code>a = b</code>.</p>
</li>
<li>
<p>Composite assignment of any of the above: <code>a += b</code>, <code>a &amp;= b</code>, etc.</p>
</li>
<li>
<p>Equality and ordering: <code>a == b</code>, <code>a &gt; b</code>, <code>a &gt;= b</code>, <code>a &lt; b</code>, <code>a &lt;= b</code>.</p>
</li>
<li>
<p>Numeric negation: <code>-a</code>.</p>
</li>
</ul>
<h2 id="numbers-conversion"><a class="header" href="#numbers-conversion">Numbers Conversion</a></h2>
<p>The underlying type of a numeric value is platform-specific and can be any
Rust primitive numeric type such as <code>usize</code>, <code>isize</code>, <code>f64</code>, <code>i32</code>, etc.</p>
<p>The script engine selects the best type that suits the needs of the underlying
value representation. In scripts, numerics are represented as the generalized
<code>number</code> type, and the engine performs automatic number type conversions as
needed.</p>
<p>In general, Ad Astra numbers behave similarly to those in many other scripting
languages that do not distinguish between numeric types.</p>
<p>For this reason, script code can perform numeric operations on numbers of
different types transparently most of the time.</p>
<pre><code class="language-adastra">10 + 4.5 == 14;
10.3 + 2 == 12.3;
[18, 3.6, -9]; // Creates an array of floats.
</code></pre>
<p>When applying numeric binary operators, the script attempts to cast the
right-hand operand to the type of the left-hand operand.</p>
<p>For this reason, the script will not be able to perform this subtraction:
<code>10 - 30</code>, because the left-hand side is an unsigned integer. To make it signed,
you can prefix the literal with the <code>+</code> sign: <code>+10 - 30</code>.</p>
<p>In general, to enforce casting to a desired type, you can start the numeric
operation with a numeric literal of that type.</p>
<pre><code class="language-adastra">10 + 4.5 == 14;
0.0 + 10 + 4.5 == 14.5;
+10 - 30 == -20;
</code></pre>
<p>When the script code calls an exported Rust function with a parameter of a
specific numeric type, the script engine performs numeric conversion
automatically whenever possible.</p>
<pre><code class="language-adastra">// fn foo(usize);

foo(10);
foo(10.5); // Passes 10 by truncating the fractional part.
foo(-20); // Leads to a runtime error because -20 cannot be converted to usize.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="booleans"><a class="header" href="#booleans">Booleans</a></h1>
<p>Boolean values are constructed using the <code>true</code> and <code>false</code> keywords, as well as
through operators and methods that return booleans. For example, <code>20 &gt; 10</code>
returns a boolean <code>true</code> value.</p>
<p>For boolean values, the logical conjunction <code>a &amp;&amp; b</code>, logical disjunction
<code>a || b</code>, and logical negation <code>!a</code> operators are available.</p>
<p>Logical conjunction has a higher precedence than disjunction: <code>a &amp;&amp; b || c &amp;&amp; d</code>
means <code>(a &amp;&amp; b) || (c &amp;&amp; d)</code>.</p>
<p>Boolean values are primarily useful for branching statements that direct code
execution based on the truthfulness of a condition.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<p>Range objects can be instantiated using the <code>from..to</code> syntax. Their primary
purpose is to specify a range of unsigned integer numbers, such as indices for
array slices and iteration ranges in for statements.</p>
<pre><code class="language-adastra">let array = [10, 20, 30, 40, 50];

array[1..3] == [20, 30];

for i in 7..12 {
    dbg(i); // Prints: 7, 8, 9, 10, and 11.
}
</code></pre>
<p>The <code>from</code> and <code>to</code> parts are any expressions that can be evaluated to unsigned
integer numbers. The <code>from</code> value specifies the range's lower bound (inclusive),
and the <code>to</code> value specifies the upper bound (exclusive).</p>
<p>The upper bound should be greater than or equal to the lower bound. Otherwise,
the range is invalid, which will lead to runtime errors in most cases.</p>
<p>To construct a range with an "unlimited" upper bound, you can use the <code>max</code>
built-in constant, which evaluates to the maximum unsigned integer number
available on the current platform: <code>50..max</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>In Ad Astra, a function is any object that supports the invocation operator:
<code>foo(10, "bar")</code>.</p>
<p>Typically, these objects include script-defined functions, struct methods, and
functions or methods exported by the host system (via Rust).</p>
<h2 id="script-defined-functions"><a class="header" href="#script-defined-functions">Script-Defined Functions</a></h2>
<pre><code class="language-adastra">let func = fn(a, callback) {
    return a + callback(2);
};

func(10, fn(arg) arg * 5) == 20;
</code></pre>
<p>Script-defined functions are anonymous first-order objects that are usually
assigned to variables, struct fields, or passed to other functions as callbacks.</p>
<p>Ad Astra does not impose restrictions on input function parameter types or the
output result data type, but the number of arguments must match the number of
the function's formal parameters.</p>
<p>There are two forms of script function syntax:</p>
<ul>
<li>A multi-line function with a block of code as its body: <code>fn() {}</code>.</li>
<li>A one-line function: <code>fn() expr</code>.</li>
</ul>
<p>The one-line function is syntactic sugar for the multi-line function that
evaluates the provided expression and returns its value: <code>fn() { return expr; }</code>.</p>
<p>By default, a multi-line script-defined function returns nil data unless the
function's body explicitly returns a value (via the <code>return expr;</code> statement).</p>
<p>Each Ad Astra script-defined function is an independent unit of execution. When
the script passes a script function as a callback to an exported Rust function,
the host system can evaluate this function in place or independently from the
original script execution.</p>
<p>In particular, Ad Astra specializations can provide multi-threaded script
execution capabilities through this mechanism.</p>
<p>The host system can also transfer a script function defined in one script module
into another script module, thereby enabling multi-module scripting
environments.</p>
<h2 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h2>
<p>Function parameters are the variables associated with the values provided to the
function as arguments during the function invocation.</p>
<p>These parameter variables are always considered initialized. As a result, the
script cannot pass an uninitialized variable into a function during its
invocation.</p>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>A script-defined function can refer to any identifier available in the namespace
where the function was declared.</p>
<p>These references remain valid even if the referred variable outlives the
function. In such cases, the function continues to refer to the variable's data
object for the duration of the function's lifetime.</p>
<pre><code class="language-adastra">let outer_func = fn() {
    let closure = 10;

    let func = fn(arg) closure + arg;

    func(20) == 30;

    closure *= 5;

    func(20) == 70;

    return func;
};

let inner_func = outer_func();

inner_func(30) == 80;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<p>Ad Astra supports a built-in syntax for creating structural data objects.</p>
<p>Informally, Ad Astra structures are key-value data objects that resemble
JavaScript objects, Lua tables, or Rust BTreeMaps. They serve the purpose of
object-oriented organization in script code design.</p>
<pre><code class="language-adastra">let my_object = struct {
    field_1: 100,

    field_2: 200,
    
    some_method: fn(a, b) {
        self.field_2 = self.field_1 * (a + b);
    },
};

my_object.some_method(3, 4);

my_object.field_2 == 700;
</code></pre>
<p>A structure object is constructed using the <code>struct</code> keyword followed by a
definition body enclosed in <code>{...}</code> braces. The body consists of key-value
entries separated by commas, with an optional trailing comma.</p>
<p>The key of an entry can be any valid Ad Astra identifier or an unsigned integer.
The value of an entry can be any expression.</p>
<p>Structure values can be accessed using the field access operator:
<code>my_object.field_2</code>.</p>
<p>Similar to script functions, structures are anonymous objects that are typically
assigned to variables or passed directly to other expressions.</p>
<h2 id="fields-management"><a class="header" href="#fields-management">Fields Management</a></h2>
<p>The script code can add new structure entries by assigning values to new object
fields.</p>
<pre><code class="language-adastra">let my_object = struct {
    field_1: 10,
};

my_object.field_2 = 20;
my_object.field_3 = fn() {};

my_object.field_1? == true;
my_object.field_2? == true;
my_object.field_3? == true;
my_object.field_4? == false;
</code></pre>
<p>The existence of a structure entry can be tested using the <code>?</code> nil-test operator
on the structure field: <code>foo.bar?</code>.</p>
<p>Ad Astra does not provide a built-in way to remove entries from structures, but
such a feature could be implemented via exported functions.</p>
<h2 id="structure-methods"><a class="header" href="#structure-methods">Structure Methods</a></h2>
<p>A method of a structure is an entry where the value is a script function.</p>
<p>Inside the method implementation, you can use the built-in special <code>self</code>
variable, which refers to the structure instance.</p>
<pre><code class="language-adastra">let my_object = struct {
    field: 10,
    method_1: fn() self.field * 3,
};

my_object.method_2 = fn() self.field * 4;

my_object.field = 100;

my_object.method_1() == 300;
my_object.method_2() == 400;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="mutability-1"><a class="header" href="#mutability-1">Mutability</a></h1>
<p>In Ad Astra, all data is always passed by reference to heap-allocated memory.</p>
<p>The mutability of an object of a particular type is determined by the set of
implemented operators and methods that collectively shape the type's interface.
This interface may provide full or partial capabilities for mutating the
referred data.</p>
<p>For example, Ad Astra's built-in numbers and booleans are inherently mutable
objects, but strings and functions are fully immutable.</p>
<h2 id="assignment-operator"><a class="header" href="#assignment-operator">Assignment Operator</a></h2>
<p>The assignment operator <code>a = b</code> is a standard binary operator that may or may
not be implemented for a given type.</p>
<p>The purpose of this operator is to replace the data referred to by the left
operand with the data referred to by the right operand.</p>
<p>Most built-in and exported types usually implement this operator, but there are
exceptions.</p>
<p>For example, all numeric types implement assignment, but the script function
type does not. Therefore, script code can reassign numbers but cannot reassign
functions.</p>
<pre><code class="language-adastra">let x = 10;

x = 20;

let func = fn(a, b) a + b;

// Assignment to function is forbidden.
// func = fn(a, b) a * b;
</code></pre>
<h2 id="variables-are-immutable"><a class="header" href="#variables-are-immutable">Variables are Immutable</a></h2>
<p>Formally, all Ad Astra variables are immutable named slots that store references
to data objects.</p>
<p>Once a variable is initialized with a value, it cannot be reassigned. All
subsequent assignments will be interpreted by the engine as a call to the
binary <code>=</code> operator on the type.</p>
<pre><code class="language-adastra">let x;

x = 10; // Initializes the variable with the value.

x = 20; // Calls the binary assignment operator: "=(x, 20)".
</code></pre>
<h2 id="built-in-types-mutability"><a class="header" href="#built-in-types-mutability">Built-In Types Mutability</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Assignment</th><th>Mutability</th></tr></thead><tbody>
<tr><td>All <code>number</code> types</td><td>Implemented</td><td>Fully mutable.</td></tr>
<tr><td>Boolean <code>bool</code> type</td><td>Implemented</td><td>Fully mutable.</td></tr>
<tr><td>String <code>str</code> type</td><td>Unimplemented</td><td>Not mutable.</td></tr>
<tr><td>Range <code>range</code> type</td><td>Unimplemented</td><td>Not mutable.</td></tr>
<tr><td>Function types</td><td>Unimplemented</td><td>Not mutable.</td></tr>
<tr><td>Structure <code>struct</code> type</td><td>Unimplemented</td><td>Partially mutable. New fields can be added.</td></tr>
<tr><td>Non-singleton arrays</td><td>Unimplemented</td><td>Individual elements of the array may be mutable.</td></tr>
</tbody></table>
</div>
<p>Note that non-built-in exported types usually implement the assignment operator
and are typically inherently mutable objects.</p>
<h2 id="boxing"><a class="header" href="#boxing">Boxing</a></h2>
<p>The built-in semantics of Ad Astra covers only the base use cases, assuming that
growable arrays, strings, and other immutable constructions do not require data
mutation out of the box.</p>
<p>Engine specializations may expose additional APIs that allow the script user to
mutate some or all data types, depending on the specialization domain.</p>
<p>For example, a concrete specialization might implement mutable string builders,
vectors, or even general mutable boxing objects.</p>
<pre><code class="language-adastra">let sb = string_builder();

sb.push("hello");
sb.push(" ");
sb.push("world");

sb.build() == "hello world";
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<p>All Ad Astra types, including built-in and custom exported types, are
essentially the types of the host system (Rust types).</p>
<p>Script users cannot define new types within scripts. Instead, they must be
provided by the language specialization in Rust. The system of exported Rust
types defines the structure of the script domain.</p>
<p>The set of all types known to the script engine is global. While types cannot be
referred to directly in scripts, the static analyzer and interpreter are aware
of the types associated with manageable script data objects.</p>
<h2 id="arrays-1"><a class="header" href="#arrays-1">Arrays</a></h2>
<p>Arrays are a fundamental aspect of the type system's semantics. In Ad Astra,
arrays don't have a dedicated type; rather, every data object in a script is
inherently an array.</p>
<p>For example, both <code>305</code> and <code>[305]</code> are singleton arrays. Typically, most script
objects are singleton arrays, which are arrays with just one element.</p>
<p>Ad Astra arrays are flat memory allocations with a fixed number of contiguous
elements of the same type.</p>
<p>Arrays are flat in the sense that script code cannot express nested arrays
without boxing: <code>[1, 2, 3, 4]</code> and <code>[1, [2, 3], 4]</code> are considered equivalent
data entities.</p>
<p>For simplicity, the static script code analyzer does not distinguish between
singleton arrays and arrays with more than one element, assuming that the length
of the array is semantically transparent.</p>
<pre><code class="language-adastra">// The analyzer assumes that all of the following variables have a `bool`
// type regardless of the array length.

let x = true;
let y = [false];
let z = [true, false, true];
</code></pre>
<h2 id="strings-1"><a class="header" href="#strings-1">Strings</a></h2>
<p>Ad Astra strings are arrays of unsigned bytes that encode UTF-8 sequences.</p>
<p>The script engine manages strings slightly differently from normal script
arrays. Specifically, the engine infers this type as the built-in <code>str</code> type
rather than as a <code>number</code> type.</p>
<h2 id="nil-type"><a class="header" href="#nil-type">Nil Type</a></h2>
<p>Another special type is the <code>nil</code> type. This type does not have instances that
point to any memory allocations.</p>
<p>In scripts, a Nil object can be constructed as an array without elements: <code>[]</code>.</p>
<p>Additionally, script-defined functions that do not return any data have a <code>nil</code>
return type. An exported function, method, or operator that returns Rust's <code>()</code>
unit type on behalf of the script returns a Nil object.</p>
<p>To check if a data object is not Nil, the script code uses the built-in <code>?</code>
unary operator.</p>
<pre><code class="language-adastra">10? == true; // `10` is not nil.

[]? == false;

let func = fn() {};

func()? == false;

let x = 10;

(x += 5)? == false; // The result of the assignment operator is nil.
</code></pre>
<h2 id="polymorphism-and-type-casting"><a class="header" href="#polymorphism-and-type-casting">Polymorphism and Type Casting</a></h2>
<p>Ad Astra types are unique, monomorphic Rust types.</p>
<p>In general, data objects of distinct types are incompatible. If an exported API
function, method, or operator expects a data object of a specific type, the
script must provide an argument of that expected type.</p>
<p>Depending on the domain-specific specialization, some data types may offer
automatic conversion between objects of distinct types.</p>
<p>For example, the built-in numeric objects support automatic conversion, allowing
script code to pass an integer to a function that expects a floating-point
number.</p>
<h2 id="type-families"><a class="header" href="#type-families">Type Families</a></h2>
<p>A type family is a set of types that are semantically related.</p>
<p>They are designed for the convenience of script users. For instance, all
built-in numeric types (e.g., <code>usize</code>, <code>f32</code>, <code>i64</code>, <code>u8</code>) belong to a single
<code>number</code> type family.</p>
<p>The analyzer refers to them by the family name rather than by their specific
type names, and it typically does not produce a warning if the script code
passes an object of one type to a function that expects another type, as long as
both types belong to the same family.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="memory-model"><a class="header" href="#memory-model">Memory Model</a></h1>
<p>Data objects in scripts are always passed by reference to a heap memory
allocation.</p>
<p>This includes primitive types as well. For instance, if the script code
introduces a boolean value using the <code>true</code> keyword, the result of this
expression is a reference to the heap where the boolean data object is
allocated.</p>
<p>The script engine maintains a counter for the active references to script data,
ensuring that the object's data allocation persists until the last reference is
released.</p>
<pre><code class="language-adastra">let x = 500; // Variable `x` contains a reference to the numeric object "500".

x /= 10; // `x` is passed by reference.

dbg(x); // `x` is passed by reference too.

// The end of the `x` lifetime.

dbg("Done");
</code></pre>
<p>Function closures prolong data lifetimes:</p>
<pre><code class="language-adastra">let func;

{
    let x = 5;
    
    // The function captures the data referred to by `x`.
    func = fn() { return x; };
    
    // The lifetime of the variable `x` ends here,
    // but the data it refers to remains alive.
}

dbg(func()); // Prints "5".

// The lifetime of the function ends here, along with its closure
// to the numeric object "5".
</code></pre>
<h2 id="data-projections"><a class="header" href="#data-projections">Data Projections</a></h2>
<p>Script code can create a projection of one referential data object to a subset
of its memory.</p>
<p>For example, when script code refers to an array by index or range, the
interpreter does not create a copy of the element(s). Instead, it returns a
reference to the array slice.</p>
<pre><code class="language-adastra">let array = [10, 20, 30];

// The `array[1]` expression returns a reference to the second element
// of the array.
let second = array[1];

// Mutates an element of the original array.
second = 200;

// Prints "200".
dbg(array[1]);
</code></pre>
<p>If this behavior is not desirable, the script code can copy the referred data
using the <code>*foo</code> cloning unary operator.</p>
<pre><code class="language-adastra">let array = [10, 20, 30];

let second_copy = *(array[1]);

second_copy = 200;

dbg(array[1]); // Prints "20".
</code></pre>
<h2 id="dereferencing"><a class="header" href="#dereferencing">Dereferencing</a></h2>
<p>All data operations requested from scripts are eventually performed by the host
system (Rust code).</p>
<p>When a script sums two numbers, the operation is executed by the Rust function
that implements the <code>a + b</code> operator, taking both operands by value.</p>
<p>Passing by value means transferring the data allocation from the script memory
to the host system (or implicitly cloning the data if there are multiple active
script references to it).</p>
<p>In general, the host code can access script data immutably, mutably, or by
taking the data by value (which may require immutable access for cloning).</p>
<p>The type of data access is usually indicated by the corresponding exported
function signature. For example, the host function
<code>fn foo(a: &amp;usize, b: &amp;mut bool)</code> accesses the first argument immutably and the
second argument mutably.</p>
<p>Script code does not need to manually dereference provided arguments; data
dereferencing is handled automatically by the script engine.</p>
<p>However, this implicit dereferencing must comply with Rust's general rules of
exclusive access:</p>
<ul>
<li>There can be as many simultaneous active immutable dereferences of the same
data allocation as needed.</li>
<li>But if the data is dereferenced mutably, other simultaneous mutable or
immutable dereferences are forbidden.</li>
</ul>
<p>Data dereferencing is managed by the script engine, and failure to comply with
these rules results in runtime errors.</p>
<p>Such errors are rare because, typically, data dereferencing is localized.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="api-overview"><a class="header" href="#api-overview">API Overview</a></h1>
<p>The Ad Astra project aims to develop an embedded scripting language
infrastructure integrated into end applications.</p>
<p>Typically, this infrastructure includes the following components:</p>
<ul>
<li>A script compiler and interpreter.</li>
<li>A static code analyzer that verifies the syntax and semantic consistency of
script source code, printing possible diagnostic errors and warnings to the
terminal (or another output).</li>
<li>Language extensions for code editors to assist users during script
development.</li>
<li>A source code formatter program.</li>
</ul>
<p>The Ad Astra <a href="https://crates.io/crates/ad-astra">crate</a> provides the necessary
APIs to implement these components for a custom domain-specific scripting
language based on the Ad Astra language.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples">examples</a>
directory in the Ad Astra repository contains sample setups.</p>
<p>This tutorial will guide you through the most common API functions of the crate.
For in-depth learning, refer to the
<a href="https://docs.rs/ad-astra">API Documentation</a>.</p>
<h2 id="language-customization"><a class="header" href="#language-customization">Language Customization</a></h2>
<p>To extend the base language, you can export Rust APIs such as module types,
functions, methods, operators, etc., into the script environment using the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/attr.export.html">#[export]</a> attribute
macro.</p>
<pre><code class="language-rust">#[export]
pub fn round(value: f64) -&gt; i64 {
    value.round() as i64
}

#[export]
impl Matrix {
    pub fn rotation(angle: f64) -&gt; Self {
        let (sin, cos) = angle.sin_cos();

        Self {
            x: Vector { x: cos, y: -sin },
            y: Vector { x: sin, y: cos },
        }
    }
}</code></pre>
<p>The underlying Rust items will be introspected by the macro and exposed in the
script, fulfilling the script's domain-specific environment.</p>
<p>The <code>#[export]</code> macro has certain configuration options that will be explained
in the tutorial, but typically, exporting works without extra effort.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/algebra/src/lib.rs">Algebra Example</a>
demonstrates a typical use of the export macro.</p>
<h2 id="analyzer-and-interpreter"><a class="header" href="#analyzer-and-interpreter">Analyzer and Interpreter</a></h2>
<p>To implement the analyzer for a script module, you instantiate a
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/struct.ScriptModule.html">ScriptModule</a>
object into which you load the source text of the script.</p>
<p>For example, you can load the text from disk:</p>
<pre><code class="language-rust ignore">let text = read_to_string(&amp;cli.path).expect("Script file read error.");

let module = ScriptModule::new(Package::meta(), text);</code></pre>
<p>After creating the script module, you can query this object for diagnostic
errors and warnings and print them to the terminal.</p>
<pre><code class="language-rust ignore">let handle = TriggerHandle::new();
let read_guard = module.read(&amp;handle, 1).expect("Module read error.");

let diagnostics = read_guard.diagnostics(1).expect("Module analysis error.");

if !diagnostics.is_empty() {
    // Prints all errors and warnings, if any.
    println!("{}", diagnostics.highlight(&amp;read_guard.text(), !0));
}</code></pre>
<p>If there are no errors, you can compile the script module into assembly and run
this assembly in the Ad Astra Virtual Machine.</p>
<pre><code class="language-rust ignore">let assembly = read_guard.compile().expect("Script compilation error.");

match script_fn.run() {
    Ok(_) =&gt; println!("Script execution finished."),

    // Otherwise, prints the runtime error.
    Err(error) =&gt; println!(
        "Script execution failure:\n{}",
        error.display(&amp;read_guard.text()),
    ),
}</code></pre>
<p>Depending on your implementation goals, you can continuously watch the source
code file for changes and repeat the above steps to provide continuous script
execution.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/runner">Runner Example</a>
demonstrates this kind of setup.</p>
<h2 id="code-editor-extension"><a class="header" href="#code-editor-extension">Code Editor Extension</a></h2>
<p>As a separate program, you can configure and run a language server that
interacts with the code editor through the
<a href="https://microsoft.github.io/language-server-protocol/">LSP</a> protocol. This
server assists the script user in the editor with code completions, type hints,
identifier references, and many other features useful for live code development.</p>
<pre><code class="language-rust ignore">fn main() {
    LspServer::startup(
        LspServerConfig::new(),
        LspLoggerConfig::new(),
        LspTransportConfig::Stdio,
        Package::meta(),
    );
}</code></pre>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/lsp-server">LSP Server Example</a>
demonstrates a language server setup.</p>
<p>To implement the code editor extension, you need to create an LSP client as a
plugin for the code editor. This implementation is editor-specific, so you
should consult the documentation of the particular editor you are targeting.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/lsp-client">LSP Client Example</a>
is a sample LSP client setup for VS Code.</p>
<h2 id="code-formatter"><a class="header" href="#code-formatter">Code Formatter</a></h2>
<p>Additionally, you can set up a separate Rust program that formats the source
text of the Ad Astra script into a canonical form.</p>
<p>The <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/format/fn.format_script_text.html">ad_astra::format::format_script_text</a>
function takes a string of the source code, formats it, and returns the
formatted version of the text.</p>
<p>This setup is optional, as the LSP server offers built-in formatting
capabilities.</p>
<h2 id="web-assembly-build"><a class="header" href="#web-assembly-build">Web-Assembly Build</a></h2>
<p>The Ad Astra crate is WASM-compatible. Specifically, you can implement a special
setup of the script language infrastructure, including the language's runner and
code editor, that works entirely within a web browser without requiring a
separate web server.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/wasm">WebAssembly Example</a>
demonstrates a setup of the script language runner and the LSP server compatible
with the <code>wasm32</code> target. In this setup, the server-side operates in the
browser's web worker, while the client side is a customized Monaco editor that
interacts with the local LSP server running in the web worker.</p>
<p>This example is also available in the <a href="developer-guide/../playground.html">Ad Astra Playground</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="exporting-1"><a class="header" href="#exporting-1">Exporting</a></h1>
<p>To export semantics from Rust to a script, you would use the <code>#[export]</code>
attribute macro.</p>
<p>This macro automatically introspects the underlying Rust item, making it
available in the script environment.</p>
<p>Typically, you would export Rust crate functions, statics, constants, struct
types, and their <code>impl</code> blocks, including the implemented operators.</p>
<h2 id="export-macro-anatomy"><a class="header" href="#export-macro-anatomy">Export Macro Anatomy</a></h2>
<p>The macro should be applied to the Rust item.</p>
<p>For example, this application is allowed:</p>
<pre><code class="language-rust ignore">#[export]
impl Foo {
    pub fn bar(&amp;self) {}
}</code></pre>
<p>But the following export is <strong>forbidden</strong> because the implementation method
itself is not a Rust item:</p>
<pre><code class="language-rust ignore">// Missing `#[export]` annotation on the impl block.
impl Foo {
    #[export]
    pub fn bar(&amp;self) {}
}</code></pre>
<p>The <code>export</code> attribute may appear multiple times inside the introspected item and
on the same Rust construct to specify more export details.</p>
<pre><code class="language-rust ignore">#[export]
impl Foo {
    // Private methods are not exported by default.
    // By annotating this method with an additional `#[export]` attribute,
    // you enforce the method's export.
    #[export]
    fn bar(&amp;self) {}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="script-packages"><a class="header" href="#script-packages">Script Packages</a></h1>
<p>The script package is the only structure required for exporting from the Rust
crate into the script environment.</p>
<pre><code class="language-rust ignore">#[export(package)]
// The script package must implement the Default trait.
#[derive(Default)]
struct Package;</code></pre>
<p>This object represents the metadata of the current crate, and there should be no
more than a single exported script package per crate.</p>
<p>Typically, you place this object in the <code>lib.rs</code> or <code>main.rs</code> entry point of the
crate. However, the location is optional. The Ad Astra engine can recognize
exported Rust items regardless of their implementation location and visibility
level.</p>
<p>Other exported crate functions, statics, and constants will be exported on
behalf of the crate's script package. Script modules will be evaluated based on
the semantics exported into the script package.</p>
<p>For example, if you have an exported function <code>deg</code>, running the script code on
behalf of this crate's script package will make this function available in the
script.</p>
<pre><code class="language-rust ignore">#[export(package)]
#[derive(Default)]
struct Package;

#[export]
pub fn deg(degrees: f64) -&gt; f64 {
    PI * degrees / 180.0
}

let script_module = ScriptModule::new(Package::meta(), "deg(120);");</code></pre>
<h2 id="package-visibility"><a class="header" href="#package-visibility">Package Visibility</a></h2>
<p>The visibility level of the exported package object is up to the implementation.</p>
<p>By making this object public, you allow your crate's API users to run Ad Astra
scripts on behalf of this crate directly. This may or may not be desirable
depending on the level of encapsulation you want for your crate's API.</p>
<h2 id="package-dependencies"><a class="header" href="#package-dependencies">Package Dependencies</a></h2>
<p>The dependencies of your script package are the dependencies of your crate
(as specified in the <code>Cargo.toml</code> file) that also have exported script packages,
regardless of the script package object's visibility.</p>
<p>For instance, in the <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/exporting">Exporting Example</a>,
the <code>algebra</code> crate is a Rust library that exports some Rust APIs into the local
script package of this library.
The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/runner">Runner Example</a>
is a Rust program that has <code>algebra</code> as a Cargo dependency and its own
ScriptPackage as well.</p>
<p>When the Runner program runs scripts, the script code imports semantics from the
<code>algebra</code> package using the import statement.</p>
<pre><code class="language-adastra">use algebra;

// `vec` is an exported function in the `algebra` package.

let v = vec(0.0, 1.0);

// Alternatively, the script code can refer to identifiers from dependencies
// by the package names.

let v = algebra.vec(0.0, 1.0);

// The `crate` keyword refers to the current package, where all exported
// semantics reside, including the names of the dependent packages.

let v = crate.algebra.vec(0.0, 1.0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>To export a crate-global function, you should annotate it with the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/attr.export.html">#[export]</a> attribute macro.</p>
<pre><code class="language-rust ignore">#[export]
fn round(value: f64) -&gt; i64 {
    value.round() as i64
}</code></pre>
<p>The parameter types and the return type must be types that are also exported to
the script environment<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>By default, eligible types include:</p>
<ul>
<li>All Rust primitive numeric types: <code>isize</code>, <code>f32</code>, <code>u8</code>, etc.</li>
<li>The boolean type: <code>bool</code>.</li>
<li>Rust string types: <code>&amp;str</code> and <code>String</code>.</li>
<li>Ranges of unsigned integers: <code>Range&lt;usize&gt;</code>, <code>RangeFrom&lt;usize&gt;</code>, etc.</li>
<li>The unit type <code>()</code>.</li>
<li>Tuples of other eligible types: <code>(bool, String)</code>.</li>
<li>Slices and fixed-size arrays of eligible types: <code>&amp;[u32]</code>, <code>[u32; 6]</code>, etc.</li>
<li>A box of an eligible type: <code>Box&lt;(bool, String)&gt;</code>.</li>
<li>An option of an eligible type: <code>Option&lt;[u8; 12]&gt;</code>.</li>
<li>A copy-on-write object of an eligible type with an implicit <code>'static</code>
lifetime: <code>Cow&lt;str&gt;</code>.</li>
<li>A result of an eligible type: <code>Result&lt;usize, Err&gt;</code>, where the error variant
must be a Rust standard error type that is <code>Send + Sync + 'static</code>.</li>
<li>Certain forms of callback functions.</li>
</ul>
<p>To make additional types eligible, they should be exported either in this crate
or in any dependency crate.</p>
<h2 id="function-names"><a class="header" href="#function-names">Function Names</a></h2>
<p>All exported crate functions, regardless of their Rust visibility, will be
available in scripts within a common flat namespace, under the script package of
the crate, using their original Rust function names.</p>
<p>Therefore, their names must be unique within the crate.</p>
<p>To export two independent functions with the same name, you should rename them.</p>
<pre><code class="language-rust ignore">#[export]
fn foo() {}

mod bar {
    #[export(name "foo_from_bar")]
    fn foo() {}
}</code></pre>
<p>In the script environment, these functions will be exposed as follows:</p>
<pre><code class="language-adastra">foo();
foo_from_bar();

// Or:

crate.foo();
crate.foo_from_bar();
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>You can export functions with references in the input positions if the lifetimes
of the references are elided. In other words, you can specify references, but
you cannot explicitly specify their lifetimes.</p>
<pre><code class="language-rust ignore">#[export]
fn addup(result: &amp;mut usize, arg_1: &amp;usize, arg_2: usize) {
    *result += *arg_1 + arg_2;
}</code></pre>
<pre><code class="language-adastra">let result = 10;
 
addup(result, 7, 2);

result == 19;
</code></pre>
<h2 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h2>
<p>You can use callback functions as types for the input and output of exported
functions, but only in certain forms.</p>
<pre><code class="language-rust ignore">#[export]
fn foo(
    arg_1: usize,
    arg_2: Box&lt;dyn Fn(usize, usize) -&gt; RuntimeResult&lt;String&gt; + Send + Sync&gt;,
) -&gt; RuntimeResult&lt;String&gt; {
    let mut result = arg_2(arg_1, 10)?;
    
    result.push_str(". Some suffix".);
    
    Ok(result)
}</code></pre>
<pre><code class="language-adastra">let result = foo(50, fn(x, y) ["Result is: ", x + y]);

result == "Result is: 60. Some suffix.";
</code></pre>
<p>The callback function must be a boxed Rust anonymous function (<code>Box&lt;dyn&gt;</code>) that
accepts up to 7 arguments and returns a value wrapped in the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/type.RuntimeResult.html">RuntimeResult</a>
result object.</p>
<p>The function passed into the Rust code is likely to be a script-defined function
that will be evaluated by the Ad Astra runtime, which can be error-prone.</p>
<p>The exported function implementation can pass the callback's errors back to the
script environment. Therefore, in the example above, the function <code>foo</code> also
returns a <code>RuntimeResult</code>.</p>
<p>To simplify Rust signatures, you can use one of the predefined type aliases for
callbacks.</p>
<pre><code class="language-rust ignore">use ad_astra::runtime::ops::Fn2;

// The first two Fn2 generic parameters are the types of the inputs,
// and the last one is the result type.
#[export]
fn foo(arg_1: usize, arg_2: Fn2&lt;usize, usize, String&gt;) -&gt; RuntimeResult&lt;String&gt; {
    let mut result = arg_2(arg_1, 10)?;
    
    result.push_str(". Some suffix.");
    
    Ok(result)
}</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Or types that can be cast to exported types. For example, the
<code>Option&lt;f32&gt;</code> type is not an exported type, but the engine is capable of casting
a Rust <code>Option</code> to the exported <code>f32</code> type.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>By exporting a Rust <code>struct</code> type, you register this type in the script engine,
allowing other exported items (e.g., Rust functions) to refer to it.</p>
<pre><code class="language-rust ignore">#[export]
#[derive(Debug, Clone, Copy, PartialEq)]
struct Vector {
    // Only the public fields will be exposed in scripts by default.
    pub x: f64,
    
    // Enforce private field exposure by annotating the field with `#[export]`.
    #[export]
    y: f64,
    
    // Read-only fields will be exposed as read-only in scripts.
    #[export(readonly)]
    pub z: f64,
}

// Referring to Vector as an exported function parameter.
#[export]
fn foo(v: &amp;Vector) {}</code></pre>
<p>The exported Rust structure must be of a type that is <code>Send + Sync + 'static</code>.
Therefore, you cannot export a structure with non-static lifetime references.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>By default, the macro exposes only the public fields to the scripting
environment. However, you can enforce exposure by annotating the field with the
<code>#[export]</code> or <code>#[export(include)]</code> attribute (both are synonyms when applied to
struct fields).</p>
<p>The field type must be one of the following:</p>
<ul>
<li>Any Rust numeric type: <code>f32</code>, <code>usize</code>, etc.</li>
<li>The <code>bool</code> type.</li>
<li>The unit <code>()</code> type.</li>
<li>A range (<code>Range</code>) type.</li>
<li>Any exported struct type.</li>
</ul>
<p>Note that, in contrast to functions, you cannot expose a structure field with a
type like <code>Option&lt;usize&gt;</code>.</p>
<p>To bypass this limitation, you can prevent public field exposure using the
<code>#[export(exclude)]</code> annotation and expose the struct field value using
corresponding getters and setters.</p>
<pre><code class="language-rust ignore">#[export]
struct Foo {
    #[export(exclude)]
    pub bar: Option&lt;usize&gt;,
}

#[export]
impl Foo {
    pub fn get_bar(&amp;self) -&gt; &amp;Option&lt;usize&gt; {
        self.bar
    }
    
    pub fn set_bar(&amp;mut self, bar: Option&lt;usize&gt;) {
        self.bar = bar;
    }
}</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>To export associated implementation members of the exported structure, you
should export the corresponding <code>impl</code> block of the structure.</p>
<pre><code class="language-rust ignore">#[export]
impl Vector {
    #[export(name "vec")]
    pub fn new(x: f64, y: f64, z: f64) -&gt; Self {
        Self { x, y, z }
    }

    pub fn radius(&amp;self) -&gt; f64 {
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()
    }

    pub fn normalize(&amp;mut self) -&gt; &amp;mut Self {
        let r = self.radius();

        self.x /= r;
        self.y /= r;
        self.z /= r;

        self
    }
}</code></pre>
<pre><code class="language-adastra">let v = vec(1.0, 3.7, 9.0);

v.normalize();

v.radius() == 1.0;
</code></pre>
<p>Similarly to struct fields, the exporting system exposes only public methods by
default. Therefore, if an implementation has a non-public method that you want
to expose, or a public method that you don't want to export, you should
annotate them with the <code>#[export(include)]</code> and <code>#[export(exclude)]</code> attributes,
respectively.</p>
<p>There are two types of associated functions:</p>
<ul>
<li>Object methods: functions that have <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as a receiver.</li>
<li>Non-methods, such as the <code>Vector::new</code> constructor from the example above.</li>
</ul>
<p>Non-methods will be exported on behalf of the script package, just like normal
crate-global functions. Their names must be unique across the exported crate
functions namespace.</p>
<p>Usually, you would assign more type-specific names to constructors, such as
renaming the <code>Vector::new</code> function using the <code>#[export(name = "vec")]</code>
attribute.</p>
<p>In contrast, type methods with a receiver belong to the namespace of the
exported type. Their names must be unique only within the type's namespace.
For example, <code>Vector::radius</code> does not need renaming even if you export another
type with a method of the same name.</p>
<p>Finally, exported methods may return references with the same lifetime as the
receiver's lifetime. The <code>Vector::normalize</code> is an example of such a method.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>The export macro recognizes the derives of standard Rust traits such as <code>Clone</code>,
<code>PartialEq</code>, <code>Debug</code>, etc.</p>
<p>By exporting these trait implementations, you enable certain features that the
script user can utilize with the type instances.</p>
<p>If the exported structure has a <code>#[derive(...)]</code> attribute, this attribute must
follow the <code>#[export]</code> attribute.</p>
<pre><code class="language-rust ignore">#[export]
// These derives will be recognized by the export macro.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Vector {
    pub x: f64,
    pub y: f64,
}</code></pre>
<p>Alternatively, you can export these traits manually by exporting the
corresponding implementations.</p>
<pre><code class="language-rust ignore">#[export]
impl Display for Vector {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_fmt(format_args!("vec({}, {})", self.x, self.y))
    }
}</code></pre>
<h2 id="supported-traits"><a class="header" href="#supported-traits">Supported Traits</a></h2>
<p>In addition to standard derivable traits, the export system supports the
majority of traits from the <a href="https://doc.rust-lang.org/std/ops/index.html">std::ops</a>
module and some other standard Rust traits.</p>
<div class="table-wrapper"><table><thead><tr><th>Rust Trait</th><th>Script Operators</th></tr></thead><tbody>
<tr><td><code>Clone</code> and/or <code>Copy</code></td><td>Copying: <code>*foo</code></td></tr>
<tr><td><code>Debug</code> and/or <code>Display</code></td><td>Stringification: <code>["Foo is ", foo]</code></td></tr>
<tr><td><code>PartialEq</code> and/or <code>Eq</code></td><td>Equality: <code>a == b</code> and <code>a != b</code></td></tr>
<tr><td><code>PartialOrd</code> and/or <code>Ord</code></td><td>Comparison: <code>a &gt;= b</code>, <code>a &lt; b</code>, etc.</td></tr>
<tr><td><code>Hash</code></td><td>Used implicitly</td></tr>
<tr><td><code>Default</code></td><td>Used implicitly</td></tr>
<tr><td><code>Add</code> / <code>AddAssign</code></td><td>Addition: <code>a + b</code> / <code>a += b</code></td></tr>
<tr><td><code>Sub</code> / <code>SubAssign</code></td><td>Subtraction: <code>a - b</code> / <code>a -= b</code></td></tr>
<tr><td><code>Mul</code> / <code>MulAssign</code></td><td>Multiplication: <code>a * b</code> / <code>a *= b</code></td></tr>
<tr><td><code>Div</code> / <code>DivAssign</code></td><td>Division: <code>a / b</code> / <code>a /= b</code></td></tr>
<tr><td><code>Not</code></td><td>Logical negation: <code>!a</code></td></tr>
<tr><td><code>Neg</code></td><td>Numeric negation: <code>-a</code></td></tr>
<tr><td><code>BitAnd</code> / <code>BitAndAssign</code></td><td>Bitwise conjunction: <code>a &amp; b</code> / <code>a &amp;= b</code></td></tr>
<tr><td><code>BitOr</code> / <code>BitOrAssign</code></td><td>Bitwise disjunction: <code>a | b</code> / <code>a |= b</code></td></tr>
<tr><td><code>BitXor</code> / <code>BitXorAssign</code></td><td>Bitwise exclusive disjunction: <code>a ^ b</code> / <code>a ^= b</code></td></tr>
<tr><td><code>Shl</code> / <code>ShlAssign</code></td><td>Bitwise left shift: <code>a &lt;&lt; b</code> / <code>a &lt;&lt;= b</code></td></tr>
<tr><td><code>Shr</code> / <code>ShrAssign</code></td><td>Bitwise right shift: <code>a &gt;&gt; b</code> / <code>a &gt;&gt;= b</code></td></tr>
<tr><td><code>Rem</code> / <code>RemAssign</code></td><td>Remainder of division: <code>a % b</code> / <code>a %= b</code></td></tr>
</tbody></table>
</div>
<p>Note that the assignment script operator (<code>a = b</code>) is implicitly implemented for
exported Rust structures. For this reason, exporting just the <code>Add</code> trait
implementation is enough to enable the <code>a += b</code> script operator.</p>
<pre><code class="language-rust ignore">// Implements + operator between two vectors.
#[export]
impl Add for Vector {
    type Output = Self;

    fn add(mut self, rhs: Self) -&gt; Self::Output {
        self.x += rhs.x;
        self.y += rhs.y;

        self
    }
}</code></pre>
<pre><code class="language-adastra">let v = vec(0.0, 1.0) + vec(1.0, 0.5);

// In this case, this is a syntax sugar for using `v + vec(-5.0, 0.0)`,
// where the result is then assigned to the left-hand side.
v += vec(-5.0, 0.0);

v == vec(-4.0, 1.5);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>If the exported item has Rustdoc comments, these comments will be exported as
well, and the script user will see them in the code editor.</p>
<pre><code class="language-rust ignore">/// Documentation for the function.
#[export]
pub fn deg(degrees: f64) -&gt; f64 {
    PI * degrees / 180.0
}

/// Documentation for the Vector type.
#[export]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Vector {
    /// Documentation for the `vector.x` field.
    pub x: f64,
    pub y: f64,
}

#[export]
impl Vector {
    /// Documentation for the Vector constructor.
    #[export(name = "vec")]
    pub fn new(x: f64, y: f64) -&gt; Self {
        Self { x, y }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="statics-and-consts"><a class="header" href="#statics-and-consts">Statics and Consts</a></h1>
<p>You can export <code>static</code> and <code>const</code> items, along with associated implementation
fields.</p>
<p>The exported values will be available for reading in the script package
namespace.</p>
<pre><code class="language-rust ignore">#[export]
static FOO: usize = 10;

#[export(name "BAZZ")]
const BAR: f32 = 30;</code></pre>
<pre><code class="language-adastra">FOO == 10;
BAZZ == 30;

// Or:

crate.FOO == 10;
crate.BAZZ == 30;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="advanced-export"><a class="header" href="#advanced-export">Advanced Export</a></h1>
<p>In this tutorial, we covered the basic exporting features of Ad Astra that
should address most practical use cases. However, the export system supports a
broader set of features.</p>
<p>To briefly mention a few:</p>
<ul>
<li>The export macro supports polymorphic types with type generics, handled
through type monomorphization.</li>
<li>The export macro also supports traits and trait implementations. While the
export system does not export traits themselves, it can export implemented
members of traits on specified types.</li>
<li>Exporting custom Rust types (e.g., enums) through type aliases.</li>
<li>Implementing type casting through the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/trait.Downcast.html">Downcast</a>
and <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/trait.Upcast.html">Upcast</a>
interfaces.</li>
<li>More script operators, such as implementing the <code>a = b</code> assignment operator on
a type or a custom field access resolver.</li>
<li>Exporting functions with dynamic parameters and/or result types.</li>
</ul>
<p>For further reading, refer to the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/attr.export.html">Export macro</a> documentation
and the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/index.html">ad_astra::runtime</a>
crate module documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="analysis"><a class="header" href="#analysis">Analysis</a></h1>
<p>You are loading script files into the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/struct.ScriptModule.html">ScriptModule</a>
objects for preliminary static analysis of the script's code semantics and
compilation into the Ad Astra Virtual Machine assembly.</p>
<pre><code class="language-rust ignore">let module = ScriptModule::new(
    Package::meta(),
    "let x = 10; x + 2; dbg(x);",
);</code></pre>
<p>The first argument, <code>Package::meta()</code>, of the script module constructor is a
reference to the metadata of the script package from which the script will be
analyzed and interpreted.</p>
<p>The second argument is the script's source code, which you can load from a
script file.</p>
<p>A script module is a mutable object that does not perform code analysis
instantly. Instead, it provides interfaces to incrementally query certain
features of the source code, in accordance with recent edits to the source text.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="access-guards"><a class="header" href="#access-guards">Access Guards</a></h1>
<p>Script modules are designed for script semantic analysis in multi-threaded
applications. Even though you can use this interface perfectly well in a
single-threaded application, we need to discuss its API a little further.</p>
<p>The design of the ScriptModule is somewhat similar to a read-write lock: it is
an object that can be shared between threads (e.g., by wrapping it in
<code>Arc&lt;ScriptModule&gt;</code>), and the threads access the underlying data through a
system of read and write guards.</p>
<p>The read guards provide read-only operations on the module content. This kind of
access is non-exclusive, allowing as many simultaneous read guards across
independent threads as needed, provided there is no active write guard.</p>
<p>The write guard provides both read and write operations. This kind of access is
exclusive, meaning that when write access is granted, no other read or write
guards can be active.</p>
<pre><code class="language-rust ignore">let handle = TriggerHandle::new();
let read_guard = module.read(&amp;handle, 1).expect("Module read error.");</code></pre>
<p>The <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/struct.ScriptModule.html#method.read">ScriptModule::read</a>
and <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/struct.ScriptModule.html#method.write">ScriptModule::write</a>
functions request read and write access, respectively.</p>
<p>Both functions require a handle argument
(<a href="https://docs.rs/lady-deirdre/latest/lady_deirdre/analysis/struct.TriggerHandle.html"><code>TriggerHandle</code></a>)
and a guard priority (<code>1</code>).</p>
<p>The handle is an object that allows you to manually revoke the access grant.
For instance, you can clone this object, transfer it to another thread, and
<a href="https://docs.rs/lady-deirdre/latest/lady_deirdre/analysis/struct.TriggerHandle.html#method.trigger">trigger</a>
it to revoke access.</p>
<p>Typically, you should use a unique instance of the handle for each read and
write access request.</p>
<p>The second argument, the priority number, determines the priority of the
operations you intend to perform with this guard.</p>
<p>For example, if there are active read guards with a priority of 2, and another
thread attempts to request a write guard with a priority of 3, the read guards
will be revoked. However, if the write access priority is 1, the request will
block the current thread until all read guards with a priority of 2 are released.</p>
<h2 id="multi-threaded-applications"><a class="header" href="#multi-threaded-applications">Multi-Threaded Applications</a></h2>
<p>In multi-threaded applications, where threads may simultaneously request
different types of access operations with distinct priorities, any function
returning a
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/type.ModuleResult.html">ModuleResult</a>
may result in a
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/enum.ModuleError.html#variant.Interrupted">ModuleError::Interrupted</a>
error.</p>
<p>This result indicates that the access grant has been revoked. In this event,
you should typically drop the access guard (if any), put the current thread on
hold for a short amount of time to allow another thread to obtain access with
higher priority, and then retry the operation.</p>
<pre><code class="language-rust ignore">loop {
    let handle = TriggerHandle::new();

    let read_guard = match module.read(&amp;handle, 5) {
        Ok(guard) =&gt; guard,
        Err(ModuleError::Interrupted(_)) =&gt; {
            sleep(Duration::from_millis(100));
            continue;
        }
        Err(other) =&gt; todo!("{other}"),
    };

    let diagnostics = match read_guard.diagnostics(2) {
        Ok(diagnostics) =&gt; diagnostics,
        Err(ModuleError::Interrupted(_)) =&gt; {
            sleep(Duration::from_millis(100));
            continue;
        }
        Err(other) =&gt; todo!("{other}"),
    };

    return diagnostics;
}</code></pre>
<h2 id="single-threaded-applications"><a class="header" href="#single-threaded-applications">Single-Threaded Applications</a></h2>
<p>In a single-threaded application, or in a multi-threaded application where each
script module is managed exclusively by a dedicated thread, the situation of
simultaneous access is practically impossible, and the
<code>ModuleError::Interrupted</code> error should never occur.</p>
<p>Therefore, in practice, you can more confidently unwrap the results of the
analysis API functions, which simplifies the overall design.</p>
<p>For instance, the
<a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/runner">Runner Example</a>
application is a single-threaded application that unwraps module results.</p>
<pre><code class="language-rust ignore">let handle = TriggerHandle::new();

let read_guard = module.read(&amp;handle, 5).expect("Module read error.");

let diagnostics = read_guard.diagnostics(2).expect("Module analysis error.");

return diagnostics;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="module-text"><a class="header" href="#module-text">Module Text</a></h1>
<p>The <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/struct.ModuleText.html">ModuleText</a>
object provides access to the original source code of the script.</p>
<p>You can print this object to the terminal, or you can extract a substring of the
source code within specified ranges.</p>
<pre><code class="language-rust ignore">let module = ScriptModule::new(
    Package::meta(),
    "let x = 10;\nlet y = 20;\nlet z = 30;",
);

// Assigns a user-facing name to the script module. 
module.rename("Example Module");

let handle = TriggerHandle::new();
let read_guard = module.read(&amp;handle, 1).unwrap();

let module_text = read_guard.text();

// Fetches the second line of the source text.
let second_line = module_text.substring(Position::new(2, 1)..Position::new(3, 1));
assert_eq!(second_line, "let y = 20;\n");

println!("{module_text}");</code></pre>
<p>Displaying the <code>ModuleText</code> object prints the following snippet:</p>
<pre><code class="language-text">   ╭──╢ module [‹doctest›.‹Example Module›] ╟──────────────────────────────────╮
 1 │ let x = 10;                                                               │
 2 │ let y = 20;                                                               │
 3 │ let z = 30;                                                               │
   ╰───────────────────────────────────────────────────────────────────────────╯
</code></pre>
<p>The output snippet's look and feel can be configured via the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/struct.ModuleText.html#method.snippet">ModuleText::snippet</a>
function. Using this interface, you can set the snippet's header, footer, and
annotate specific fragments of the source code.</p>
<pre><code class="language-rust ignore">let mut snippet = module_text.snippet();

snippet.set_caption("Snippet Caption");
snippet.set_summary("Summary line 1.\nSummary line 2.");
snippet.annotate(
    Position::new(2, 5)..Position::new(2, 6),
    AnnotationPriority::Default,
    "Annotation of the variable.",
);

println!("{snippet}");</code></pre>
<p>Prints:</p>
<pre><code class="language-text">   ╭──╢ Snippet Caption [‹doctest›.‹Example Module›] ╟─────────────────────────╮
 1 │ let x = 10;                                                               │
 2 │ let y = 20;                                                               │
   │     ╰╴ Annotation of the variable.                                        │
 3 │ let z = 30;                                                               │
   ├───────────────────────────────────────────────────────────────────────────┤
   │ Summary line 1.                                                           │
   │ Summary line 2.                                                           │
   ╰───────────────────────────────────────────────────────────────────────────╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h1>
<p>The first thing you should do with the script module before compiling and
running user script code is analyzing the source code for syntax and semantic
issues.</p>
<p>There are two types of issues:</p>
<ul>
<li><strong>Diagnostic Errors</strong>: These are hard errors. The analyzer is confident that
these issues must be fixed in the source code at all costs.</li>
<li><strong>Diagnostic Warnings</strong>: The analyzer has detected a piece of code that is
likely problematic, but it is unsure if it would lead to a runtime bug due to
the dynamic nature of the Ad Astra script. For example, passing an argument of
the wrong type to a function would result in a warning. The analyzer
recommends fixing these issues, but it's ultimately up to the user.</li>
</ul>
<p>Additionally, there are three levels of analysis depth, ordered by their
severity:</p>
<ol>
<li>Syntax errors.</li>
<li>Semantic errors and warnings inferred locally.</li>
<li>Deep semantic analysis of the code for possible diagnostic warnings.</li>
</ol>
<p>The issues at the lower depth levels are easier to detect and are the most
severe.</p>
<p>Before compiling the script, it is recommended to check the script module at
least for diagnostic errors at the first two levels of diagnostics.</p>
<pre><code class="language-rust ignore">let module = ScriptModule::new(
    Package::meta(),
    "let x = 10;\nlet 20;\nlet z = 30;",
);
module.rename("Example Module");

let handle = TriggerHandle::new();
let read_guard = module.read(&amp;handle, 1).unwrap();

for depth in 1..=3 {
    let diagnostics = read_guard.diagnostics(depth).unwrap();

    // The `!0` argument is the severity mask.
    // In this case, we are checking for both diagnostic errors and warnings.
    if diagnostics.len(!0) == 0 {
        continue;
    }

    let module_text = read_guard.text();

    // Prints diagnostic errors and warnings.
    // The `highlight` function returns an annotated snippet.
    println!("{}", diagnostics.highlight(&amp;module_text, !0));

    return;
}

println!("No issues detected.");</code></pre>
<p>Prints:</p>
<pre><code class="language-text">   ╭──╢ diagnostics [‹doctest›.‹Example Module›] ╟─────────────────────────────╮
 1 │ let x = 10;                                                               │
 2 │ let 20;                                                                   │
   │     ╰╴ missing var name in 'let &lt;var&gt; = &lt;expr&gt;;'                          │
 3 │ let z = 30;                                                               │
   ├───────────────────────────────────────────────────────────────────────────┤
   │ Errors: 1                                                                 │
   │ Warnings: 0                                                               │
   ╰───────────────────────────────────────────────────────────────────────────╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="editing"><a class="header" href="#editing">Editing</a></h1>
<p>The script module is an editable object. You can change the entire source code
or just a part of it whenever the user modifies corresponding fragments of the
code.</p>
<p>Due to the incremental nature of script analysis, source code edits are
efficient operations. The analyzer does not rebuild the entire inner semantic
representation of the code with every edit. Instead, it patches its inner
structures according to the changes whenever the API user queries corresponding
semantic features (e.g., when you query code diagnostics).</p>
<p>To edit the code, you should obtain the script module's write guard.</p>
<pre><code class="language-rust ignore">let module = ScriptModule::new(Package::meta(), "let x = 10;");
module.rename("Example Module");

let handle = TriggerHandle::new();
let mut write_guard = module.write(&amp;handle, 1).unwrap();

// An absolute source code character range.
//
// Alternatively, you can use a line-column range:
//     `Position::new(1, 5)..Position::new(1, 6)`.
//
// The `..` range specifies the entire text range:
//     `write_guard.edit(.., "let new_variable_name = 10;").unwrap();`
write_guard.edit(4..5, "new_variable_name").unwrap();

let module_text = write_guard.text();

println!("{module_text}");</code></pre>
<p>Prints:</p>
<pre><code class="language-text">   ╭──╢ module [‹doctest›.‹Example Module›] ╟──────────────────────────────────╮
 1 │ let new_variable_name = 10;                                               │
   ╰───────────────────────────────────────────────────────────────────────────╯
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="advanced-analysis"><a class="header" href="#advanced-analysis">Advanced Analysis</a></h1>
<p>The script module interface offers additional features for syntax and semantic
analysis of the script's source code:</p>
<ul>
<li>The <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/trait.ModuleWrite.html#method.completions">completions</a>
function returns all possible code completion candidates at the specified
cursor point.</li>
<li>The <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/trait.ModuleRead.html#method.symbols">symbols</a>
function allows manual inspection of the source code's syntax constructions
and the semantic relations between them.</li>
</ul>
<p>These and other features provide low-level components for the development of
language servers and source code analysis tools for the Ad Astra language from
scratch, which are usually unnecessary for typical use case scenarios.
For further reading, see the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/index.html">analysis</a> and
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/symbols/index.html">analysis::symbols</a>
API documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h1>
<p>To evaluate the script, you need to compile the script module into a
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/interpret/struct.ScriptFn.html">ScriptFn</a>
object, an Ad Astra Virtual Machine assembly object ready for execution.</p>
<pre><code class="language-rust ignore">let module = ScriptModule::new(Package::meta(), "return \"hello world\";");

let handle = TriggerHandle::new();
let mut read_guard = module.read(&amp;handle, 1).unwrap();

// Compiles the script.
let script_fn = read_guard.compile().unwrap();

// Runs the compiled assembly.
match script_fn.run() {
    Ok(result) =&gt; {
        // Prints: "hello world".
        println!("{}", result.stringify(false));
    }

    Err(error) =&gt; {
        let module_text = read_guard.text();

        println!("{}", error.display(&amp;module_text));
    }
}</code></pre>
<p>The <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/analysis/trait.ModuleRead.html#method.compile">compile</a>
function compiles the script module. Note that this function is capable of
compiling scripts with diagnostic issues, and even if the source code contains
syntax errors. Normally, you should not compile and run such scripts, but if you
do, the compiler will attempt to produce assembly code that aligns as closely as
possible with the original script author's intentions.</p>
<p>To run the script, you call the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/interpret/struct.ScriptFn.html#method.run">ScriptFn::run</a>
function, which executes the compiled assembly on the current thread until
completion and returns a runtime result, which is either a value returned from
the script or a
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/enum.RuntimeError.html">RuntimeError</a>.</p>
<p>In the code above, we print the result using the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/struct.Cell.html#method.stringify">Cell::stringify</a>
function, assuming that the object (a string in this case) implements the
Display or Debug traits. Alternatively, to get the exact value returned from the
script, you can use functions like
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/struct.Cell.html#method.take">Cell::take</a>
instead.</p>
<p>If the script returns a runtime error, this error indicates a bug that occurred
during script evaluation, and you should print this error to the terminal as
well:</p>
<pre><code class="language-text">   ╭──╢ runtime error [‹doctest›.‹#2›] ╟───────────────────────────────────────────╮
   │        ╭╴ receiver origin                                                     │
 1 │ return "hello world" + 1;                                                     │
   │                      ╰╴ type 'str' does not implement + operator              │
   ├───────────────────────────────────────────────────────────────────────────────┤
   │ The object's type that is responsible to perform specified operation does not │
   │ implement this operator.                                                      │
   ╰───────────────────────────────────────────────────────────────────────────────╯
</code></pre>
<h2 id="isolation"><a class="header" href="#isolation">Isolation</a></h2>
<p>By default, the <code>ScriptFn::run</code> function executes the script to completion on
the current thread.</p>
<p>In practice, the script's execution time is unlimited, and the execution process
may never end. For example, the script might contain an infinite loop that would
never terminate.</p>
<p>To limit the execution process, you can set a thread-local hook that triggers on
each Ad Astra assembly command before it is evaluated, allowing the Rust
environment to interrupt the script execution manually.</p>
<p>If the script execution is interrupted, the <code>run</code> function will return the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/runtime/enum.RuntimeError.html#variant.Interrupted">RuntimeError::Interrupted</a>
variant.</p>
<pre><code class="language-rust ignore">let module = ScriptModule::new(Package::meta(), "loop {}");

let handle = TriggerHandle::new();
let mut read_guard = module.read(&amp;handle, 1).unwrap();

let script_fn = read_guard.compile().unwrap();

let start = Instant::now();

// If the provided hook function returns true, the script runtime continues
// execution. Otherwise, the execution will be interrupted, and the `run`
// function will return an `Interrupted` error.
set_runtime_hook(move |_| start.elapsed().as_secs() &lt;= 5);

match script_fn.run() {
    Ok(result) =&gt; {
        println!("{}", result.stringify(false));
    }

    Err(RuntimeError::Interrupted { .. }) =&gt; {
        println!("Script execution lasts too long.");
    }

    Err(error) =&gt; {
        let module_text = read_guard.text();

        println!("{}", error.display(&amp;module_text));
    }
}</code></pre>
<p>Note that although the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/interpret/fn.set_runtime_hook.html">set_runtime_hook</a>
function gives you more control over script evaluation, it slows down the
evaluation process because the provided callback is invoked at each step of
script execution.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="language-server"><a class="header" href="#language-server">Language Server</a></h1>
<p>The language server is a Rust program that provides semantic analysis metadata
for the code editor (the language client) through the
<a href="https://microsoft.github.io/language-server-protocol/">LSP</a> protocol.</p>
<p>The LSP language server is an essential component of the code editor's language
xtension plugin.</p>
<p>The Ad Astra crate includes a built-in LSP server that you can run using the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/server/struct.LspServer.html#method.startup">LspServer::startup</a>
function. This function performs all necessary preparations to establish
communication with the language client according to the specified configuration
and runs the actual server that assists the code editor user.</p>
<pre><code class="language-rust ignore">// General LSP server configuration features.
// Through this object, you can enable or disable certain LSP features.
// The default configuration suits the majority of practical needs.
let server_config = LspServerConfig::new();

// Sets up the server-side and client-side loggers.
//
// The client-side logs are end-user facing messages that will be shown
// in the editor's console (this may vary depending on the editor's user
// interface). Usually, these logs are less verbose and include only general
// messages about the server state.
//
// The server-side logs usually include client-side messages too, but they also
// include additional messages useful for server debugging.
//
// By default, the server uses the STDERR channel (because the STDIO channel may
// be used as the actual LSP communication transport between the server and the
// client). You can manually configure this option to redirect log messages to
// the Unix Syslog or to a custom function.
let logger_config = LspLoggerConfig::new();

// The LSP communication transport. The STDIO channel is the default option
// supported by the majority of code editors that support the LSP protocol.
let transport_config = LspTransportConfig::Stdio;

LspServer::startup(
    server_config,
    logger_config,
    transport_config,
    
    // A script package on behalf of which the files opened in the code editor
    // will be analyzed.
    Package::meta(),
);</code></pre>
<p>Usually, you would implement the LSP server as a separate Rust executable
program and bundle it with the code editor extension. The editor would run this
program, establishing communication through the STDIO channel of the program's
process.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/lsp-server">Language Server Setup</a>
example provides a sample setup of the language server.</p>
<p>In addition to the STDIO transport, some language clients also support TCP
communication transport, where the LSP server is started independently from the
client, and the client connects to the TCP port opened by the server (or by the
client).</p>
<p>This communication mode is less common than the STDIO transport but is more
useful for server debugging during the development of the code editor extension.
In particular, if you start the server's process manually in the terminal, you
will also see its STDERR debugging logs in the terminal.</p>
<p>The Ad Astra built-in server supports both types of communication transports.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/lsp-client">Language Client Example</a>
demonstrates a VS Code extension that works with the Ad Astra LSP Server
through one of the transports, depending on the user's preference.</p>
<div style="break-before: page; page-break-before: always;"></div><!------------------------------------------------------------------------------
  This file is part of "Ad Astra", an embeddable scripting programming
  language platform.

  This work is proprietary software with source-available code.

  To copy, use, distribute, or contribute to this work, you must agree to
  the terms of the General License Agreement:

  https://github.com/Eliah-Lakhin/ad-astra/blob/master/EULA.md

  The agreement grants a Basic Commercial License, allowing you to use
  this work in non-commercial and limited commercial products with a total
  gross revenue cap. To remove this commercial limit for one of your
  products, you must acquire a Full Commercial License.

  If you contribute to the source code, documentation, or related materials,
  you must grant me an exclusive license to these contributions.
  Contributions are governed by the "Contributions" section of the General
  License Agreement.

  Copying the work in parts is strictly forbidden, except as permitted
  under the General License Agreement.

  If you do not or cannot agree to the terms of this Agreement,
  do not use this work.

  This work is provided "as is", without any warranties, express or implied,
  except where such disclaimers are legally invalid.

  Copyright (c) 2024 Ilya Lakhin (Илья Александрович Лахин).
  All rights reserved.
------------------------------------------------------------------------------->
<h1 id="web-assembly"><a class="header" href="#web-assembly">Web Assembly</a></h1>
<p>The Ad Astra crate supports WebAssembly (Wasm) build targets, specifically the
<code>wasm32-unknown-unknown</code> target.</p>
<p>The compiled Wasm module can be loaded and run in browsers, including the script
language static analyzer, runner, and language server. However, this setup
requires additional preparations.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/wasm">WebAssembly Example</a>
provides a full-featured setup of these components for the browser environment.
You can see it in action in the <a href="developer-guide/../playground.html">Ad Astra Playground</a>.</p>
<h2 id="exports"><a class="header" href="#exports">Exports</a></h2>
<p>For desktop build targets, the <code>Export</code> macro automatically exports
introspection metadata by linking the generated exporting functions in a special
link section.</p>
<p>However, the Wasm build target does not have a fully-featured linker. Therefore,
you must call these functions manually after the Wasm module is loaded and
before the module is actually used.</p>
<pre><code class="language-javascript">// Loading a WebAssembly file.
const assembly = fetch('./wasm.wasm');

// Compiling the file in the browser.
WebAssembly.instantiateStreaming(assembly, IMPORTS).then(({instance}) =&gt; {
    // Calling each module-exported function that starts with the special
    // `__ADASTRA_EXPORT_` prefix.
    //
    // These functions are generated by the Export macro.
    // By invoking them manually, you register the corresponding item's
    // introspection metadata in the Ad Astra script engine's exports registry.
    for (const property in instance.exports) {
        if (property.startsWith('__ADASTRA_EXPORT_')) {
            instance.exports[property]();
        }
    }

    // The module is now ready for use.
});
</code></pre>
<h2 id="lsp-server"><a class="header" href="#lsp-server">LSP Server</a></h2>
<p>The built-in LSP server that you would normally run using the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/server/struct.LspServer.html#method.startup">LspServer::startup</a>
function spawns additional threads for the communication channel and the actual
LSP server instance.</p>
<p>Common LSP communication transports such as STDIO and TCP are unavailable in the
Wasm environment. Additionally, the browser's Wasm environment does not support
multi-threading.</p>
<p>To organize the LSP server in this environment, you would typically instantiate
the LSP server manually using the
<a href="https://docs.rs/ad-astra/1.0.0/ad_astra/server/struct.LspServer.html#method.new">LspServer::new</a>
function and manually manage communication between the language server and the
language client.</p>
<p>The <a href="https://github.com/Eliah-Lakhin/ad-astra/tree/master/work/examples/wasm">WebAssembly Example</a>
example demonstrates running the Wasm module in a separate web worker,
establishing communication through a system of serialized post-messages passed
between the worker and the browser environment.</p>
<p>The <a href="https://docs.rs/ad-astra/1.0.0/ad_astra/server/struct.LspServer.html#method.handle">LspServer::handle</a>
function processes deserialized incoming LSP messages, synchronously yielding
outgoing messages. The corresponding implementation reads these messages on the
Rust side, serializes them into strings, and sends these strings back to the
browser environment.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>







        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
